<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>再谈“开源软件供应链安全”</title>
    <url>/flossway/2022/01/15/Talking-again-about-OSS-Supply-Chain/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>之前写过一篇文章《<a href="/2021/05/12/about-OSS-Supply-Chain.html">我所理解的开源软件供应链安全</a>》，当时的情况，还没有出现一些值得探讨的，堪称紧迫的热点事件，所以我也仅仅是泛泛而谈，到最后留了一句话：「我的提议是：不再提“开源供应链安全”，而是提“开源生态建设”。」</p>
<p>在最近一段时间，接连出现了Log4j2事件，与Marak Squires删库事件，一时间大家都议论纷纷，我也觉得自己有责任，来更加深入的探讨一下，这个方面的问题。</p>
<h2 id="一、时代已经发生了变化"><a href="#一、时代已经发生了变化" class="headerlink" title="一、时代已经发生了变化"></a>一、时代已经发生了变化</h2><p>在B站上，有一位著名的Up主：<strong>半佛仙人</strong>，发了一篇文章，后来还专门录了一期视频。因为是“外行”的缘故，所以会受到很多的批评与指责。其实我觉得他说得大致上都很有道理，作为一位热心人士，积极找程序员朋友交流，尽量深入理解开源，然后再发表自己看法，已经非常不错了。</p>
<p>至少<strong>半佛</strong>的一个观点，我特别赞同：时代已经发生了变化。我们只有意识并理解这些变化，然后才谈得上“如何应对”。</p>
<span id="more"></span>

<h3 id="比尔盖茨的一封信"><a href="#比尔盖茨的一封信" class="headerlink" title="比尔盖茨的一封信"></a>比尔盖茨的一封信</h3><p>1976年2月3日，著名的微软公司的创始人，发布了《致电脑爱好者的一封公开信》。这封信在开源社区，估计无人不知、无人不晓。关键在于下面这段话：“谁会从事专业的软件开发却分文无获。哪有业余爱好者会花费3个人年的精力去编写软件，去修正软件，编写使用手册却免费发放给别人使用？”</p>
<p>在很长一段时间里，开源社区的人都视微软是开源的敌人，而且常常喜欢拿段话出来“打脸”。现在就是有那么多人，那么多技术水平高超，却不求回报的人，愿意花费极其惊人的时间，去写软件，修bug，写文档。甚至还有社区运营、技术布道等等诸多工作。</p>
<p><strong>“你们这些资本家们无法理解的事情，正在这个世界上发生着，而且越来越多”。</strong></p>
<h3 id="早期的黑客是一群什么人？"><a href="#早期的黑客是一群什么人？" class="headerlink" title="早期的黑客是一群什么人？"></a>早期的黑客是一群什么人？</h3><p>有一些事情，确实很难理解。尤其是像半佛这样的人，无法理解那些早期黑客的动机。因为按照“理性经济人”的假设，那些黑客完全是在做一些一味付出，不求回报的事情。</p>
<p>事实上，我们可以从两个角度，来理解黑客的逻辑。</p>
<ul>
<li>关于回报：如果我们扩展经济人假设，将回报，不仅仅局限于经济上的，金钱的，直接的回报。而是按照功利主义的定义：“效用最大化”。所谓效用，包括幸福、快乐、满足等等情感体验。通过获得经济收入，当然是一种方式。但是：社会地位的提升，甚至仅仅是在社区范围内的备受尊崇，也是一种方式。更有甚至，仅仅是创造一个从未存在过的事物，这种创造的喜悦，就足以回报那些黑客的全部投入。</li>
<li>关于未来：黑客、程序员，也许是最喜欢科幻小说的人群了吧。不仅仅是喜欢，而且他们甚至希望能够促成某种未来的早日实现。如果自己写的代码能够帮助这样的未来早日实现，如果与一群黑客一起努力，能够推动这样的世界早日降临，几乎每一个黑客都会愿意倾尽全力。</li>
</ul>
<p>所以，简单的总结就是：早期黑客们，在努力推动未来早日实现的过程中，已经获得了他们希望得到的回报。</p>
<h3 id="供求双方，从合一到分离"><a href="#供求双方，从合一到分离" class="headerlink" title="供求双方，从合一到分离"></a>供求双方，从合一到分离</h3><p>我们可以引用一段自由软件的定义：“自由软件”尊重用户的自由，并且尊重整个社区。粗略来讲，一个软件如果是自由软件，这意味着用户可以自由地运行，拷贝，分发，学习，修改并改进该软件。</p>
<p>后来在社区里有一些不同的声音，在质疑这样的定义。为什么只谈用户的自由，却不谈“作者”的自由？为了用户可以自由的运行，拷贝，分发，学习，修改并改进，就可以不管作者的利益了吗？作者为啥不能自由的定义自己的授权协议？想授予就授予？想收回就收回？</p>
<p>其实，根源还是在于时代不同了。在自由软件，甚至开源软件刚刚诞生的时候。软件的供求双方，是一个紧密的整体。社区里的人，既是一些软件的开发者，也是另一个软件的使用者。所谓“尊重整个社区”就是这个意思。尊重整个社区的自由，就是为了整个社区的利益。</p>
<p>在早期：开源与互联网几乎就是一对双生子，他们一起成长，互相扶持。风借火势，火借风威。但是，渐渐的，开源社区与软件产业、互联网产业，以及由互联网产业成长起来的云计算行业，不再是一体的了。在这个过程中，供应方发生了变化，需求方也发生了变化。要想再愉快的一起玩耍，就需要从新思考各自的定位了。</p>
<p>所以，下面我将从分离之后的供求双方，来分析这个问题。</p>
<h2 id="二、从“礼物文化”到“注意力兑换”"><a href="#二、从“礼物文化”到“注意力兑换”" class="headerlink" title="二、从“礼物文化”到“注意力兑换”"></a>二、从“礼物文化”到“注意力兑换”</h2><p>在Eric Raymond的《大教堂与集市》中，有一个最经典的比喻，就是礼物文化。我们引用其中的两段：</p>
<blockquote>
<p>在礼物文化下，其成员通过送出礼物而竞争社会地位。</p>
</blockquote>
<blockquote>
<p>礼物文化并不是对物质稀缺的适应，而是对物质充裕的适应。 充裕性会使命令关系难以维持，会使交换关系变成无意义的游戏。在礼物文化中，社会地位并不取决于你控制了什么，而是你给予了什么。</p>
</blockquote>
<h3 id="礼物的价值，是由礼物本身决定的？"><a href="#礼物的价值，是由礼物本身决定的？" class="headerlink" title="礼物的价值，是由礼物本身决定的？"></a>礼物的价值，是由礼物本身决定的？</h3><p>我们来分析一下礼物这个比喻的内涵。一个人送出了一个礼物。人们根据这个礼物的贵重程度，而“赋予”这个送礼者，相应的社会地位。</p>
<p>这意味着三个并未明确讲述的要素：</p>
<ul>
<li>礼物的价值是客观存在的吗？是可以被客观、准确、以公认的方式判定的吗？</li>
<li>人们，注意这里的人们，到底是一百个人，还是一万个人？这些人的数量应该会有多少，他们如何达成共识？</li>
<li>所谓社会地位，到底是什么？尊重，礼让，还是某种“注目礼”？</li>
</ul>
<h3 id="开源软件的价值，现在是由“价值-关注度”决定的"><a href="#开源软件的价值，现在是由“价值-关注度”决定的" class="headerlink" title="开源软件的价值，现在是由“价值+关注度”决定的"></a>开源软件的价值，现在是由“价值+关注度”决定的</h3><p>假设我们还是沿用“礼物”这个思路，来看现在的开源软件，我们需要如何来衡量一个人做出了多大的贡献？或者说“送出了多贵重的礼物？”</p>
<p>先区分两种情况，一个人独立开发出一款开源软件，作为一个礼物。一个人参与一个开源项目，在其中贡献了一部分“代码、文档、讨论、布道等等”</p>
<ul>
<li>首先应该是软件价值本身，一个加密软件，应该比一个加法软件，更有价值。</li>
<li>其次是这个软件究竟对多少人有价值？一个只对一百个人有用的软件，肯定不如对一百万人有用的软件，那么有价值。</li>
<li>然后就是争夺关注度的情况了，一款对一百万人有用的软件，现在只有一百个人知道，这个软件的价值说到底也不大。</li>
</ul>
<p>现在来计算礼物的价值：一个人，做了一个开源软件，有多少人知道这个软件，而且知道是他做的，而且认可他的工作。这个数量，大概可以用来推算他所贡献的礼物的价值。</p>
<h3 id="如何将注意力兑换成其他事物？"><a href="#如何将注意力兑换成其他事物？" class="headerlink" title="如何将注意力兑换成其他事物？"></a>如何将注意力兑换成其他事物？</h3><p>自从互联网流行以后，尤其是互联网上免费的商业模式流行起来以后，大家都会谈一个词，叫做“流量变现”。其实在开源软件领域，简单的“礼物文化”，也需要升级为“注意力兑换”。</p>
<p>以前的逻辑是：一个人贡献礼物 –&gt; 获得社会地位</p>
<p>现在的逻辑是：一个人贡献礼物 –&gt; 吸引了多少注意力 –&gt; 这些注意力能够兑换多少社会地位</p>
<p>当然，我们也可以将兑换这个词，用来描述更多的现象。</p>
<ul>
<li>兑换内心满足（有人用，我就很开心）</li>
<li>兑换社会地位（更高的社会评价）</li>
<li>兑换就业机会（跳槽到大厂）</li>
<li>兑换风险投资（有投资人看中这个开源软件）</li>
<li>兑换维护合同（有企业级用户使用，愿意找你维护）</li>
</ul>
<p>但是，所有的这些，还需要一个前提：注意力。如果没有足够高的关注度，你啥也兑换不了。</p>
<p>事实上，早期开源那种“爱用就用，别来烦我”的态度，当然没有问题。但是：那样不够“友好”，也就会影响关注度的快速提升。无论是在社区快速响应，和蔼可亲的回答问题，快速修复bug，其实都是一种吸引更多注意力，留住更多关注度的办法。</p>
<p>虽然这么说有些残忍，但是我还是想说：“Marak Squires的做法错了，一款开源软件有几千万次下载，并不能够自动兑换成社会地位，个人收入或者其他东西”。</p>
<h2 id="三、供应链、责任链与利益链"><a href="#三、供应链、责任链与利益链" class="headerlink" title="三、供应链、责任链与利益链"></a>三、供应链、责任链与利益链</h2><p>下面再来说说需求方的问题。现在我们常常说：软件吞噬世界，开源吞噬软件。但是，我们为啥还会接着说：云计算吞噬开源呢？</p>
<ul>
<li>软件吞噬世界：全世界都运行在软件之上</li>
<li>开源吞噬软件：几乎所有的软件，都有开源的成分，甚至完全就是开源</li>
<li>云计算吞噬开源：云计算靠开源赚到了钱，但是并没有分给开源</li>
</ul>
<p>当然，这里面的每一句话，可能都有些问题。</p>
<h3 id="由开源软件的依赖关系，自然形成的供应链"><a href="#由开源软件的依赖关系，自然形成的供应链" class="headerlink" title="由开源软件的依赖关系，自然形成的供应链"></a>由开源软件的依赖关系，自然形成的供应链</h3><p>在上一篇文章中，我写了这么一段话：“我们在做软件开发时，通常会定义的一个依赖文件。一款软件，会依赖一组其他软件（包），而这些软件（包）又会进一步的依赖某些其他的软件（包）。但是，随着包依赖描述的不断改进，我们会区分：开发期（Dev)依赖与执行期(Running)依赖。”</p>
<p>在那段话里，我只是希望说明“依赖不等于风险”，由软件依赖关系形成的整个网络，可以称之为：“开源供应链”或者“开源生态”，却不能简单的等同于供应链风险。</p>
<p>但是，我并没有进一步分析：开源软件的供应链与一般的供应链，有何区别？以下一段文字，要特别感谢李大维老师，因为与他的交谈，让我认识到这一点。</p>
<blockquote>
<p>传统的供应链，是一级与一级之间，都签了合同的。但是在软件，尤其是开源软件的供应链，每一级之间，都有免责条款。</p>
</blockquote>
<h3 id="免责条款"><a href="#免责条款" class="headerlink" title="免责条款"></a>免责条款</h3><p>事实上，有两种免责条款。一种是大多数开源软件的授权协议里写的。比如在 GPL 2.0 里。</p>
<blockquote>
<ol start="11">
<li>由于本程序是免费提供的，所以在法律许可范围内，本程序是没有担保的。除非有书面说明。本程序是“AS IS”的，没有任何明示或暗示的保证，比如默认的适销性、适用性这些保证都没有，关于本程序的功能和性能导致的风险都由用户自己承担，（你单位用我作品出了事，你可别想拉我当垫背的，大公司都不背这锅，你让我一个不挣你钱的背？）如果我这作品真有缺陷，你自己想办法搞定，你可以花钱买服务，这种公司又不是没有。</li>
</ol>
</blockquote>
<p>摘录自卫Sir的《<a href="https://mp.weixin.qq.com/s?src=11&timestamp=1642342050&ver=3562&signature=SU4bpJGGjZ3V*Lf3w1Yk5gA5VgQVbR9r9FQz4udKEmRVMr65tWp5iQQ0W-90qR9Orz0Ody0g6C*Dhmb2VBr4-blpWICL4-GyNqYFim1V1NzyMC*AAqhWB90bQKc57cTe&new=1">人话版GPL 2.0协议</a>》</p>
<p>再比如在 MIT 里：</p>
<blockquote>
<p>本软件是“按原样“提供的，不附带任何明示或暗示的保证，包括没有任何有关适销性、适用性、非侵权性保证以及其他保证。在任何情况下，作者或版权持有人，对任何权益追索、损害赔偿以及其他追责，都不负任何责任。无论这些追责产生自合同、侵权，还是直接或间接来自于本软件以及与本软件使用或经营有关的情形。</p>
</blockquote>
<p>摘录自卫Sir的《<a href="https://mp.weixin.qq.com/s?src=11&timestamp=1642342024&ver=3562&signature=HXHa3AXIOpUss850bdZFJWTdfYFVBMmQTb2Zi-W8r-U1FnKK6pw9YfCCMG7q9PjtpyG3dMlgjC5EUeV9I9DvQQVcdjIKJTr*hQ9AtS263oqpoNhSHJ2a-rfqC8LRWcTH&new=1">开源程序员绝望毁库跑路的背后</a>》<br>另一种是互联网服务的免责条款、云计算服务的免责条款、商用软件的免责条款。</p>
<p>这里就不再摘录了，因为那种法律文本，往往都很长很长，在你使用之前，你几乎是不会去读完的。但是：你肯定已经点过“确定”或者“接受”按钮了。</p>
<h3 id="利益断裂"><a href="#利益断裂" class="headerlink" title="利益断裂"></a>利益断裂</h3><p>一方面是供应链的延续性，另一方面是责任的断裂（免除）。于是，我们就会发现一个实际存在的现象：因为责任链条断裂，所以利益链条也断裂了。</p>
<p>因为事实上软件出现问题之后，厂商可能损失的金额并不太高，所以在平时厂商也没有任何动力，投入足够的人力与预算，去确保他所用到的开源软件的供应链安全。</p>
<p>前两天听到的一个课程，在介绍影响全球互联网产业的美国《通信规范法》230条款。互联网公司被免除了涉及用户生成内容的法律责任。一方面这些内容的存在不会损害互联网厂商的利益，另一方面，互联网厂商又可以出于“出于良善的信念”自行删除或管理这些内容。</p>
<p>这当然大大降低了互联网厂商的法律风险与投入成本。再加上他们所用到的开源软件，又是无需支付费用的。这才带来了互联网产业的高速发展与如今的繁荣。</p>
<h3 id="冰山现象"><a href="#冰山现象" class="headerlink" title="冰山现象"></a>冰山现象</h3><p>与此同时，我们还在开源社区里，积极的宣传礼物文化。“充裕性会使命令关系难以维持，会使交换关系变成无意义的游戏。”</p>
<p>结果就变成了：开源世界的冰火两重天</p>
<ul>
<li>一座冰山是“开源项目”，海面之上看得到的开源项目，只是开源世界里的极小部分<ul>
<li>海面之下的开源项目，不仅重要，而且是海面上的开源项目，存在的基础</li>
<li>但是，海面之下的开源项目，几乎没有商业价值，也没有投资前景</li>
</ul>
</li>
<li>另一种冰山是“开源贡献者”，海面之上的开源开发者，只是开源社区里的一小部分人<ul>
<li>他们的确做出了极大的贡献，也因此享受到了“礼物文化”</li>
<li>海面之下的开发者，他们的贡献甚至被忽略了，社区的尊崇地位，几乎与他们无关</li>
</ul>
</li>
</ul>
<h2 id="四、生态责任"><a href="#四、生态责任" class="headerlink" title="四、生态责任"></a>四、生态责任</h2><p>当我们来谈开源软件的供应链风险，或者开源生态的问题时，首先需要达成一个共识：现在的开源生态，的确存在问题，而且是一个亟待解决的，严重的问题。</p>
<p>基于这一共识，我们才能够来讨论，在这个生态之中，有哪些角色，各自有什么责任？</p>
<h3 id="开源开发者的责任"><a href="#开源开发者的责任" class="headerlink" title="开源开发者的责任"></a>开源开发者的责任</h3><p>大家应该都能承认，开源是一种软件开发的<strong>协作方式</strong>。对于某些人来说，开源甚至是一种<strong>娱乐方式</strong>。当然，如果有公司愿意雇佣你写开源代码，开源也是一种很不错的<strong>工作方式</strong>。但是，如果你希望将开源作为自己的<strong>生活方式</strong>，要么你家里有矿，要么你非常擅长兑换注意力。否则，难免会伤心失望。</p>
<p>虽然我们都认为，开源是一种纯个人的行为，但是单纯的发泄不满。最多引发同情，却未必会得到支持，更是难以获取自己真正想要的结果。</p>
<p>作为一个理性行动者，知道自己想要什么，也知道自己将要付出什么，才是一种负责人的做法。</p>
<h3 id="开源使用者的责任"><a href="#开源使用者的责任" class="headerlink" title="开源使用者的责任"></a>开源使用者的责任</h3><p>“只要足够多的眼球关注，就可让所有软件缺陷浮现。”，或者说“只要有足够的测试员及共同开发者，所有软件缺陷都会在很短时间内被发现，而且能够很容易被解决。”这句话被称之为 Linus 定律。现在我想要告诉这些开源软件的使用者，现在的开源软件已经越来越多了，眼球已经根本不够用了。</p>
<p>假设“开源软件没有质量问题，不会给你带来安全风险，完全免费，拿来就可以用。”是一种完全不负责任的冒险。</p>
<p>开源软件并不是“免费”的，任何使用开源软件的企业，都需要为自己的使用负责，要留出预算，要么找到合格的员工，要么找到合格的服务商，来帮你应对这些风险。</p>
<h3 id="开源基金会的责任"><a href="#开源基金会的责任" class="headerlink" title="开源基金会的责任"></a>开源基金会的责任</h3><p>一款开源软件，如果出现安全风险，这个开源软件的社区，应该要快速解决。如果这款开源软件被捐赠给某个开源基金会，那么这个基金会也有义务，为这个开源软件的质量负责。</p>
<p>为什么？因为：你的品牌与声望，为这款开源软件背书，使得更多的厂商选择了它。那么：如果它内含风险，你的品牌与声望，就放大了这些风险。</p>
<p>作为一个基金会，你收到的捐款，应该更多的投入到保障软件质量的工作中去！</p>
<h3 id="开源布道师的责任"><a href="#开源布道师的责任" class="headerlink" title="开源布道师的责任"></a>开源布道师的责任</h3><p>不要只是介绍“礼物文化”，不要反复的强调“Just for Fun”。不要仅仅宣传 Linus 眼球定律。在布道的时候，还需要介绍更多的真实世界的情况。</p>
<h3 id="政府的责任"><a href="#政府的责任" class="headerlink" title="政府的责任"></a>政府的责任</h3><p>2022 年 1 月 13 日，白宫就 Log4j 漏洞与公私实体召开了开源软件安全峰会。其中一名高级官员表示：“开源软件虽然加速了创新并推动了巨大的社会和经济效益，但其广泛使用且由志愿者维护的事实是重大的国家安全风险，正如我们正在经历的 Log4j 漏洞事件。它并非新问题。本次峰会我们将讨论如何解决这个问题，生效的解决方案是什么以及我们还能采取哪些行动来保护我们都在依赖的开源软件安全。”</p>
<p>引用自《<a href="https://mp.weixin.qq.com/s?__biz=MzI2NTg4OTc5Nw==&mid=2247510134&idx=1&sn=4c2520d4e86d56f7ad4cfcc073595cfc&chksm=ea94991cdde3100a908ea1ef25ff5da15d4290d3a5c52bed99b177b0086eee39814b7871f41e&scene=178&cur_album_id=1803829618517311490#rd">白宫和科技巨头在开源软件安全峰会上说了啥？</a>》</p>
<p>在我看来，各个政府，应该都会有所行动才是。</p>
<h2 id="五、结束语"><a href="#五、结束语" class="headerlink" title="五、结束语"></a>五、结束语</h2><p>这篇文章，已经太长了，引用一段我在《2021年中国开源年度报告》中的前言，作为结尾吧。</p>
<p>在开源还只是一个小众群体的业余爱好时，几乎做任何事情，都是自由的。但是，在软件吞噬世界、开源吞噬软件的今天，开源技术，已经成为整个世界的基础设施之一。能力越大，责任越大。应用越广，风险越高。我们应该如何思考与保障开源供应链安全呢？应该如何建设更加健康的开源生态呢？在这样一种生态中，各方的责任又该如何界定呢？</p>
<p>愿与诸位共同探索。</p>
]]></content>
      <categories>
        <category>庄表伟</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>供应链</tag>
      </tags>
  </entry>
  <entry>
    <title>我所理解的开源软件供应链安全</title>
    <url>/flossway/2021/05/12/about-OSS-Supply-Chain/</url>
    <content><![CDATA[<h2 id="供应链与断供"><a href="#供应链与断供" class="headerlink" title="供应链与断供"></a>供应链与断供</h2><p><strong>隐喻会帮助人，也会误导人。</strong></p>
<p>当我们谈到“供应链”时，会产生哪些联想？环环相扣？缺一不可？掉链子？当我们这样去思考软件供应链，或者开源软件供应链时，同样的“意象”也会出现在我们的脑海里。</p>
<p>一条从不知名的远处延伸到我们面前的链条，这个链条的最后一环，是一款我们看得见、用得上的软件。</p>
<p>这个链条当中，有很多环节都是别人（美国）提供的。也许有一天，美国（人）一旦决定，拿回他的那一环。我们就断供了，延伸到我们面前的链条就断掉了，我们手中正在使用的软件，就消失了。</p>
<p>这就被称为————“断供”。</p>
<h2 id="物质断供"><a href="#物质断供" class="headerlink" title="物质断供"></a>物质断供</h2><p>当一个链条是由物质构成的时候，这个“意象”并不是幻想，而是实实在在的现实。比如：芯片断供，手机缺货。GPU断供，显卡涨价。</p>
<p>当我们想要把这个情况，引申到软件、甚至开源软件领域的时候，我们必须重新定义“断供”。</p>
<p>这就带来了各种“乱象”。</p>
<span id="more"></span>

<h2 id="开源软件断供：分类"><a href="#开源软件断供：分类" class="headerlink" title="开源软件断供：分类"></a>开源软件断供：分类</h2><ul>
<li>无法下载</li>
</ul>
<p>从中国，无法下载到美国（Github）上的开源代码。或者无法及时下载到最新的源代码</p>
<ul>
<li>无法参与上游</li>
</ul>
<p>一个开源社区，用规则或潜规则，拒绝中国开发者，导致中国开发者被排除在外。我们的开发者被禁止向上游提交代码，无法参与、回馈社区</p>
<ul>
<li>修改License之一：闭源</li>
</ul>
<p>在某个版本之后，该软件不再提供开源代码</p>
<ul>
<li>修改License之二：排除特定类型用户</li>
</ul>
<p>基于某种License（不允许商业使用、不允许邪恶用途、不允许特定国家使用）</p>
<ul>
<li>生态限制</li>
</ul>
<p>开源本身不断供，但是开源所依赖的服务，无法使用</p>
<ul>
<li>代码托管平台断供</li>
</ul>
<p>整个Github不允许你使用</p>
<ul>
<li>开源软件安全风险</li>
</ul>
<p>具体某一款开源软件的某一个版本，存在安全漏洞，需要修复（或替换）</p>
<ul>
<li>项目缺少投入，无法继续发展（感谢 @Donald@CNCF@LFAPAC 的补充）</li>
</ul>
<p>一款无人维护的开源软件（维护不及时，不到位），比如曾经的OpenSSL，就是一种值得关注的风险</p>
<h2 id="《技术的本质》与其不足之处"><a href="#《技术的本质》与其不足之处" class="headerlink" title="《技术的本质》与其不足之处"></a>《技术的本质》与其不足之处</h2><p>首先推荐一本非常了不起的著作《技术的本质》（布莱恩·阿瑟），在这本书中，布莱恩提出了一些极其深刻的洞见。例如：技术的本质是对现象的驾驭。以及：技术是组合与递归的。</p>
<p>我想继续引申这个观点。类似于我们在做软件开发时，通常会定义的一个依赖文件。一款软件，会依赖一组其他软件（包），而这些软件（包）又会进一步的依赖某些其他的软件（包）。但是，随着包依赖描述的不断改进，我们会区分：开发期（Dev)依赖与执行期(Running)依赖。</p>
<p>在更加广泛的技术领域，我们也会发现类似的现象。我们发明一种新技术时（开发期），会依赖一组其他已有的技术。但是，当我们基于这个新技术，生产某一个产品时，会依赖另外一组技术（编译期），当我们的产品被实际使用时，还会依赖其他一些技术（执行期）。</p>
<p>当我们泛泛的分析技术时，可以发现其中的组合与递归结构。而当我们更加深入的分析技术的依赖关系时，会发现不同的依赖与递归结构。</p>
<h2 id="依赖与风险"><a href="#依赖与风险" class="headerlink" title="依赖与风险"></a>依赖与风险</h2><p>《技术的本质》告诉我们，依赖一定存在，而且无穷无尽。但是：依赖不能简单的等同于风险，至少不能等于同样大小的风险。</p>
<p>当我们对于开源软件，做供应链风险分析的时候。泛泛的树立一个假想敌，然后一概以风险视之，不但将风险不断放大，也将防范风险手段无限提升。</p>
<p>我认为：这并非一种理性的应对风险的策略。</p>
<h2 id="换一种隐喻"><a href="#换一种隐喻" class="headerlink" title="换一种隐喻"></a>换一种隐喻</h2><p>如果我们将“链条”的隐喻，换成“生态圈”的隐喻，来看待软件、以及开源软件所面临问题。也许会更加有利于我们朝向正确的方向前进。</p>
<p>空气、水、土壤与风，是环境的一部分。温度、湿度、海拔也是环境一部分。对于一个生态圈来说，我们虽然也提“食物链”，但是很难想象：一个单一物种的缺失，会导致整个食物链的断裂，以及食物链上端的物种全部灭绝。所以：事实上现在描述生态系统时，常用的概念是“食物网”而非“食物链”。</p>
<p>作为软件行业的从业者，我们应该关注整个生态的健康程度，以及预防可能存在的“污染”和“破坏”。甚至，考虑到生态多样性，我们也的确应该支持更多类似的软件，甚至竞争性的平台。</p>
<p>但是：这并非一场“为了防止我的链条断掉”，而发起的一场“伟大战斗”。这是一场“建设更加丰富、繁荣的软件生态的运动”。</p>
<p>所以，我的提议是：不再提“<strong>开源供应链安全</strong>”，而是提“<strong>开源生态建设</strong>”。</p>
<p>与诸君探讨。</p>
]]></content>
      <categories>
        <category>庄表伟</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>供应链</tag>
      </tags>
  </entry>
  <entry>
    <title>代码穿流</title>
    <url>/flossway/2022/02/25/code-flows-with-opensource/</url>
    <content><![CDATA[<p>玩开源的程序员，大多了解 Linus 曾经说过的那句霸气无比的话：</p>
<p><strong>Talk is cheap. Show me the code.</strong></p>
<h2 id="代码胜于雄辩"><a href="#代码胜于雄辩" class="headerlink" title="代码胜于雄辩"></a>代码胜于雄辩</h2><p>这是 Linus 于 2000 年 8 月 25 日在社区邮件列表上讨论关于 Linux 内核线程优化问题时，其中一个人提出了个他认为非常高效的方案，而 Linus 认为这个方案不够好，于是他在回信中就写下了这句在今天足以堪称经典的话，这也令很多程序员感觉非常惬意。</p>
<p>从此，每当程序员们产生各种言语纷争而又一时无果时，往往便以这句话来结束唾沫横飞的争论。一方面，我们看到的是程序员文化中“与其你口头装逼，不如代码牛逼”的内涵；另一方面，我们也可这样理解：代码胜过一切含糊不清的争论。因为平常的语言沟通，即使一个明确的想法，即使用同样的字词，却因为语境或者语法造句等因素，让自己原本想表达的构想无法被对方精准理解和捕捉，从而产生各种歧义和误解。而写出来的程序因为代码规则的标准性和编译后的可运行性产生了所见即所得的效果，让代码就不言自证了其原先想法的清晰性，正确性或者优越性。当一切用可见的代码及运行结果来说话，争论自然就偃旗息鼓。</p>
<p>Facebook 创始人扎克伯格也曾在自己公司上市的前一天发表的上市演讲中说过了类似的话，他当是这样说的：“Code wins argument（代码胜于雄辩）”。 其言下之意是想说两层意思：</p>
<ol>
<li>代码是一种比平常语言更能精确表达思想的工具。</li>
<li>代码运行出来的结果可以见证想法的恰当与否。</li>
</ol>
<p>于此，我们必须接受和承认这样一个事实：在沟通误解和语言歧义的困境面前，程序代码比日常语言有着更加精准表达的优势。程序员拥有着比普通人更好的沟通载体。这个载体就叫程序代码。代码首先是一种能清晰和精准表达思想的语言载体，其次是可以通过编译后运行来直接验证效果的沟通工具。如果说数学是最精准而抽象的语言，那么程序代码可以说是精准而同时有事半具象半抽象的语言。</p>
<span id="more"></span>

<h2 id="什么是代码穿流？"><a href="#什么是代码穿流？" class="headerlink" title="什么是代码穿流？"></a>什么是代码穿流？</h2><p>开源因为继承了由理查德斯托曼所开启的自由软件运动以来所倡导的代码开放共享精神，使得程序员们可以在拥有了代码语言进行精准表达自己构想的基础上，更可以通过这些开放且透明可见的源代码承载着他们的思想，在不同的程序员间或者开源社区的不同成员之间来回穿梭，以此充分交换和反馈各自自己的想法。我把它这个过程定义为代码穿流。而这样的代码穿流正是因为代码语言的精确性，成为了开源社区不同社区成员间的低歧义和几乎零误解的沟通载体，创造了开源社区独特的高效且有效的沟通基础。</p>
<p>一般我们认为，开源共同体的创新基础在于分布式的社会化协作。实际上，社会化协作是代码穿流后的一种结果表现。而开源的代码语言作为沟通基础，辅之以如 GitHub 一类的开源协作平台工具，直接效果当然是提高了开发效率，但究其本质其实应该是代码穿流后形成了开源共同体间的创新价值。</p>
<p>为什么这样说呢？</p>
<h2 id="知识的显性化和去粘性"><a href="#知识的显性化和去粘性" class="headerlink" title="知识的显性化和去粘性"></a>知识的显性化和去粘性</h2><p>在知识创新的领域里，实现价值创新的一个重要基础是知识的可传递。知识作为一个特殊而无形的物品，其可传递的核心是解决两个问题</p>
<ol>
<li>知识的显性化</li>
<li>知识的去粘性</li>
</ol>
<p>进而实现知识的无损耗传递。程序代码则作为人类知识领域的一部分，当然也存在同样的显性化和去粘性问题。</p>
<p>人类的显性知识是可以通过文字、数据、代码、图像等方式进行传递和学习的；而隐形知识则属于人们在长期的学习工作实践中获得并积累下来，与个体的经历及体验有关，或者只能从结果推测，且大多只能意会却难以用语言明示或学习的知识。</p>
<p>对于显性知识下的隐形知识，在翻译美国作家菲茨•吉拉德的名作《了不起的盖茨比》时，作为译者的日本著名作家村上春树在对于如何翻译好开头和结尾、该如何表达原作者想在语言中表达的情绪时，曾经如此纠结过：</p>
<blockquote>
<p>读上几遍还是只能感慨文字的美，每一个词都有丰富的含义和实质，既有深刻的暗示性，犹如乙醚般清淡，想要捕捉时它却从指尖溜走。 从这段评论中，我们可以看出在日常语言下，即使对于一个专业的作家而言，知识显性化的提取也是非常高难度。当然，菲茨•吉拉德用显性语言来故意蕴藏他想表达的隐含之美是另外一层艺术创作境界，而对于可以我们得出的一个结论是：日常语言对于知识的显性化传递是无法做到足够清晰的，同时，那些受高度语境限制且不确定的语言则更会成为粘性知识。所谓粘性知识是指必须通过近距离的观察和沟通甚至面对面的交谈才能了解获得的知识。</p>
</blockquote>
<p>大家应该知道，有个一个古老的游戏叫“拷贝不走样”。百度百科中是这样描述的：规则是先给第一个人看他要表演的话语或素材，第二个表演给第三个看，依次下传。最后一人要把他理解的意思讲出来，猜中则胜利。该游戏起源于曾经在上海电视台热播的综艺节目《智力大冲浪》。节目最早的版本其实是，人们隔着厚厚的移动墙向下一个选手传与该词相关的动作，然后最后一个人说出第一个人做的姿势的含义，往往笑倒一片观众，拷贝不走样的游戏性在于“拷贝走样”。在活动中，观众可以亲眼目睹动作渐渐走样，这是因为，清楚知道词语的 B 不一定能表达相同信息给后面的 C，动作的模仿中关键的“细节”容易遗漏，或是被 C、D、E 等人再创造而传承。</p>
<p>实际上，这个游戏的隐含意义就是粘性知识在信息的传递过程中，由于传递者自身及语言，动作姿势的模糊性及多义性，信息会被迅速衰减。从这个游戏的结果，我们大致可以得出一个粗浅的结论：粘性知识的传播是距离的衰减函数。</p>
<p>编译成二进制且不提供源代码的程序，虽然通过运行可以看到显性结果或者使用，但事实上因为代码的不可见就是一种典型的隐性且粘性的知识。传统的软件提供商在提供可运行的软件时会附带软件使用手册或者技术文档来局部显性化，也会通过一些面对面的交流沟通（这些往往以培训，现场指导等形式出现）来局部去粘性。但最直接和最透彻的显性化无疑就是提供源代码。当初自由软件运动和随后兴起的开源运动的初心，就是为了让代码知识显性化的无损穿流。</p>
<p>所以开源软件实践中，程序员通过代码编写将自己的想法精确表达出来，并且通过代码开源行动开放共享出来，就是一次非常典型的知识显性化过程，随后通过社区开展的各类活动如论坛，meetup，会议等线上线下活动进行知识的去粘性化，进而让显性化的代码知识在开源社区的不同成员间无损穿流达到分享传递和协同，让不同程序员的匠性得以聚合，最终达到社会化协同创新。</p>
<h2 id="我们的结论"><a href="#我们的结论" class="headerlink" title="我们的结论"></a>我们的结论</h2><p>所以，软件代码通过开源让软件程序的隐形知识显性化加强，显性化的知识进而通过开源社区的各类活动以最大限度去粘性化，形成代码穿流。这，应是开源集市模式卓越性的一个本质所在。这也就是代码穿流力。由此，我们可以得出第一个结论：</p>
<h3 id="结论一：开源的软件代码是软件类知识传递损耗系数最小的传递载体"><a href="#结论一：开源的软件代码是软件类知识传递损耗系数最小的传递载体" class="headerlink" title="结论一：开源的软件代码是软件类知识传递损耗系数最小的传递载体"></a>结论一：开源的软件代码是软件类知识传递损耗系数最小的传递载体</h3><p>软件代码的开源是软件知识显性化的最优方式，而积极的开源社区活动则是软件知识去粘性化的最佳手段。</p>
<p>前不久，Apache 基金会主席 David Nelly 在美国参议院的听证会上所言中看到，开源已经成为数字经济的重要基础设施。那么程序代码必然是开源创新协同的重要载体。Linux 基金会的执行董事 Jim Zemlin 曾经在 2013 年的一次 TEDx 演讲中提到这样一些数据：荷马史诗《伊利亚德》共 15000 行，《战争与和平》共 45 万字，在 Linux 项目中，每一天的每一小时至少有 7 个变化在 Linux 项目里发生，仅 2012 年就有近一百万行的代码被提交，这又是由分布在全球的 407 个公司、几千个程序员一起合作产生的结果。到今天，Linux 毫无疑义地已经成为在过去 30 年以来最成功的全球化开源协作项目。正是这些 Linux 里开源的代码穿越了时间，跨越了地理空间，更涵盖了不同种族的人群，进而造就了人类软件史上的一次伟大奇迹，这几乎和代码穿流的力量密不可分。由此，我们可以得到了代码穿流的另一个结论：</p>
<h3 id="结论二：开源的代码在时间，空间和不同人群之间穿流的程度决定了这个开源社区的价值"><a href="#结论二：开源的代码在时间，空间和不同人群之间穿流的程度决定了这个开源社区的价值" class="headerlink" title="结论二：开源的代码在时间，空间和不同人群之间穿流的程度决定了这个开源社区的价值"></a>结论二：开源的代码在时间，空间和不同人群之间穿流的程度决定了这个开源社区的价值</h3><p>我们也可以这样认为，在开源项目原始创意价值确定的前提下，开源社区的价值是代码穿流的时间，空间和人群的函数。即如果代码所穿越的群体越广泛、时间和空间，那么价值可能就越大。而它的逆否命题则可以这样描述，如果一个开源社区无法在跨时空和跨群体里穿越，那么它的创新价值有限。</p>
<p>代码穿流后，软件代码知识就不再是时间和空间的衰减函数，反而可能成为时间和空间的递增函数。进一步而言，开源社区也未必会因为多样化成岩和多元化角色间的差异衰减社区价值，它们可能表现为随着社区成员多样化和多元化，并随着成员间的争论增多而更显得有价值。那时，如果开源社区的代码如果想更快更新迭代，也未必需要社区成员很擅长懂得如何协作，也未必需要每个社区成员成为一个不敢争论的“老好人”，社区可能更多需要的是能够经常进行相互批评并能捍卫自己的想法的成员，当然这里有一个必要的前提就是对于所有的争论，最后能够以 show me the code 来终结，而 show me the code 也足以让争论分出胜负。也许我的这个想法有些乌托邦，但事实可能也就如此。</p>
<p>而关于激烈辩论有利于创新这一点，在 2003 年伯克利大学曾经做过一次称作“一个想法是如何被创造出来的？”的实验。当时，一些实验者被分成两组，其中一个组采用“传统的头脑风暴法”，即该组成员不相互批评、而鼓励每个被提出来的想法，认为没有一个想法是坏的想法。另外一个组则采用“激烈辩论法”，即小组成员相互批评各自想法，鼓励以积极的辩论去捍卫自己的想法。出乎我们的意料，这个实验最后的结果竟然是激烈辩论法的那一组获胜，相比头脑风暴组而言，他们反而产生了高出头脑风暴组一个数量级的好想法。由此，我们又得出第三个结论：</p>
<h3 id="结论三：开源社区内的激烈争论将有利于开源软件的创新"><a href="#结论三：开源社区内的激烈争论将有利于开源软件的创新" class="headerlink" title="结论三：开源社区内的激烈争论将有利于开源软件的创新"></a>结论三：开源社区内的激烈争论将有利于开源软件的创新</h3><p>当然，这基于代码语言的精准表达性和代码编译运行后的可校验性的前提。</p>
<p>Jim Zemlin 在那年的 TEDx 演讲中还如此动情地讲到：</p>
<blockquote>
<p>All of us are smarter than any one of us.  there is a whole generation of code poets out there, working furiously. Poets who love what they do, they may not get along, but are creating … These individuals have created the coal and steel of the information age … The future is a world in which can enrich your self, while at the same time enriching others.</p>
</blockquote>
<p>这就是代码穿流的威力。</p>
<p>也恰如关于乔布斯生前往事的纪录片《失落的访谈》中曾记录了乔布斯在 1995 年接受的采访中所提到的一个观点，程序语言在未来应当像其他我们日常所用来沟通的语言一样，成为我们每个人必备的交流工具。虽然这对一般普通人要求过高，但无疑他看到了代码语言作为思想的传达载体具有比数学更具象，比语言更精准的表达。</p>
<h2 id="抉择"><a href="#抉择" class="headerlink" title="抉择"></a>抉择</h2><p>如今开源的代码已经成为了软件知识传递过程中的一种最佳工具和载体。开源的内在价值取决于开源的代码在时间，空间和不同人群间的无损穿流力。我们也由此相信，任何一个开源项目的创建者在明白了开源的生命力和创新力来源于代码的穿流力之后，他们应该可以在他们所处的环境里去做出一个理智的选择，除非他们已经放弃了开源的初衷。</p>
]]></content>
      <categories>
        <category>狄安</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
        <tag>迷失的开源乌托邦</tag>
      </tags>
  </entry>
  <entry>
    <title>《知识社群》书评</title>
    <url>/flossway/2022/02/27/cultivate-communities/</url>
    <content><![CDATA[<p>时隔两年，以姜宁老师的分享为契机，我重读了<a href="https://book.douban.com/subject/35083568/">《知识社群》</a>一书。结合这两年在开源社群方向的经验，我从中发现了不少极具实践价值的内容。</p>
<p>《知识社群》一书从知识社群的社会性出发，从知识社群的历史沿革，全球知识经济的发展进程，以及知识社群在知识时代的机遇三点立论，阐述了知识社群的时代价值。进一步地，本书介绍了知识社群的三个结构要素，划分了知识社群发展的五个阶段，归纳了知识社群培养的七个原则。本书对知识社群的定义如下。</p>
<blockquote>
<p>知识社群是这样一群人，他们有共同的关注点、同样的问题或者对同一个话题的热情，通过在不断发展的基础上相互影响，深化某一领域的知识和专业技术。</p>
</blockquote>
<span id="more"></span>

<h2 id="领域、社群和实践"><a href="#领域、社群和实践" class="headerlink" title="领域、社群和实践"></a>领域、社群和实践</h2><p>本书提出的知识社群三个结构要素分别是领域、社群和实践。</p>
<blockquote>
<p>领域创造共同点和共同身份的感觉。一个明确的领域能够确定社群的目的以及它对成员和其他人的价值，从而说明社群的合理性。这样的一个领域可以鼓舞成员们做出贡献、积极参与，指导他们的学习，使他们的行动具有意义。了解领域的范围和最前沿，使得成员们能够准确地决定哪些东西值得分享，怎样提出想法，追踪哪些活动，还使他们认识到试探性或不完整的想法的潜力。</p>
</blockquote>
<p>规划一个新的开源社群，首要解决的就是核心开源软件的定位问题，也就是社群将关注在哪个技术领域。这个技术领域可以由一组用户需求，一个现有软件，或者一系列论文定义。</p>
<p>例如，Apache Kafka 一开始定位在解决日志存储和消费的业务问题上，Apache Flink 实现流式计算 API 后对标 Apache Storm 提出富有竞争力的有状态数据流计算定位，Apache Hadoop 则是对 GFS 和 MapReduce 论文的开源实现。</p>
<p>明确领域定位，才能降低开源社群成员交流的门槛。大部分的开源项目不是一个全新的问题，而是现有问题的解决或者现有方案的改良。因此，明确与现有概念之间的联系，才能够使得已经关注现有领域的人能够迅速理解新社群的领域定位，找到共同点和共同身份。不需要从头接触一个陌生的领域，而是对比与现有概念之间的联系和区别，就可以提出一系列的问题，也能理解什么问题是值得分享的。</p>
<p>例如，设计一门编程语言的时候，定位在静态类型或动态类型，就是完全不同的方向。相关领域的专家完全有可能分别拿 Haskell 和 Lisp 来比对概念上的差别，当前语言还没有实现的，尝试实现、模仿或者论证为什么不能实现。曾经对当前实现不满而因为种种原因无法落地的改进方案，抛出来与社群成员分享并争取在新项目当中实现。</p>
<p>领域的定位不是固定的问题，而是与社群一起演变的知识范围。领域的定位也不是抽象的兴趣，而是由社群共同经历的关键事件或问题组成的。</p>
<p>从现有概念延伸到新的知识社群的领域之后，社群存续下去而不是合并到现有社群的理由，就是自己的差异点。这些差异点不是一成不变的，随着不同人的加入可能发生很大的变化。例如，Apache Flink 一直在分布式计算引擎领域当中，但是在 14 年之前，它还是一个注重批处理负载的软件。直到两位开发者在 2014 年中的时候实现了 DataStream API 以后，才转向流式处理领域。例如，Perl 6 项目最初在设计上大量承袭了 Perl 的设计，并且很大程度受到那段时间的面向对象浪潮的影响。但是在 Pugs.hs 项目带来了 Haskell 社群的新鲜血液和函数式编程的思想以后，不少语言设计开始针对函数式编程的范式做出优化。而 Perl 6 的并发编程模型，则是在来自 Node.js 社群的强力开发者加入领导项目开发以后，利用 Node.js 所使用的 libuv 库搭建起来的。</p>
<p>可以看到，领域的问题都是非常具体的，能够围绕解决现有问题或改良现有方案分享知识和进行实践。领域的定位如果太过抽象，例如书中提到的“技术技巧”，那么社群就更像是一个兴趣小组甚至只是一组非常松散的圈子关系，因为围绕抽象议题提出的观点往往很难落到实处，也就很难激起社群成员的兴趣和创造价值。</p>
<blockquote>
<p>社群创造学习的社会结构。一个强大的社群能培养互动精神，培养基于相互尊重与信任的关系。他鼓励人们分享想法，暴露自己的无知，提出困难的问题，并且仔细倾听，这是一种混合的气氛：人与人有着亲密的关系，同时又相互坦诚开放地提出和探讨问题。</p>
</blockquote>
<p>社群对有效的知识结构非常关键。知识社群不仅仅是一个网站、一个知识库或者最佳实践集合，重要的是相互影响和共同学习，并在彼此之间建立联系的人。参与社群活动使社群成员形成归属感和相互的承诺。每个人分享对于某个领域共同的整体看法，而又在特定问题上带来个人的观点，这就创造了一种总和大于组成部分的社会学习结构。</p>
<p>虽然一个开源共同体可能为了推动软件的开发会建立相应的组织结构，但是在所有知识社群当中，知识的交换都是自由的，或者说去中心化的。Apache 软件基金会在 <a href="https://www.apache.org/theapacheway/index.html">The Apache Way</a> 当中强调了它所构建的开源共同体是由平等的个体所构成的。</p>
<blockquote>
<p>Community of Peers: individuals participate at the ASF, not organizations. The ASF’s flat structure dictates that roles are equal irrespective of title, votes hold equal weight, and contributions are made on a volunteer basis (even if paid to work on Apache code). The Apache community is expected to treat each other with respect in adherence to our Code of Conduct. Domain expertise is appreciated; Benevolent Dictators For Life are disallowed.</p>
</blockquote>
<p>书中提到，知识存在于人类认识事物的实践当中。它不是一种物质，不能像游戏当中双击使用书籍即可获得经验和智慧。只有通过社群的形式将关注到同一个领域上的个体聚拢起来，经过运营和管理有意识地促进知识的流动，才能促进知识的动态演进，并将知识带来的价值传达给每一个社群成员，最终使得社群成员所在的组织以及社群本身受益。</p>
<blockquote>
<p>实践是社群成员分享的一套架构、想法、工具、信息、风格、语言、故事和文件。领域指出社群关注的主题，而实践是社群开发、分享和保持的特定知识。社群建立一段时间以后，成员们认为彼此应该已经掌握了社群的基本知识。大家分享共同的知识和资源，使得社群能够高效地处理领域内的问题。</p>
</blockquote>
<p>知识社群不是魔法，它不能够直接将一个对领域一无所知的人转换成一个能够直接为社群创造核心价值的人。但是，社群可以通过实践的分享，将最佳实践总结成文档，在社群成员当中建立如何基于情景判断的共识，来提高知识社群交换知识、创造知识的效率。通过分享实践，知识社群扩大了自己的影响力，并且建立了一个隐形的参与要求。在正式成员之间，最佳实践是众所周知的，因此沟通的效率也将显著地提高。</p>
<h2 id="知识社群的发展阶段"><a href="#知识社群的发展阶段" class="headerlink" title="知识社群的发展阶段"></a>知识社群的发展阶段</h2><p>本书在介绍知识社群的发展阶段之前，首先讨论了培养知识社群的七个原则，这些原则将会贯穿不同发展阶段的关注点。</p>
<ol>
<li>精心设计社群的演化历程</li>
<li>在内部和外部的不同观点之间建立对话</li>
<li>鼓励不同程度的参与</li>
<li>既发展社群的公共空间，也发展社群的私人空间</li>
<li>以价值为关注点</li>
<li>组合熟悉和兴奋的感觉</li>
<li>构建社群节奏</li>
</ol>
<h3 id="知识社群的潜在期"><a href="#知识社群的潜在期" class="headerlink" title="知识社群的潜在期"></a>知识社群的潜在期</h3><p>知识无处不在。当围绕着同一个领域的一群人开始交换知识和实践的时候，一个非正式的知识社群就形成了。从非正式的知识社群转变成为正式的知识社群，意味着它开始强化社群的三个关键要素。</p>
<ul>
<li>关键的领域问题是定义领域的范围。</li>
<li>关键的社群问题是找到那些已经就这个主题形成网络的人，帮助他们想象网络的扩张和知识分享活动的增加会发挥怎样的价值。</li>
<li>关键的实践问题是识别共同的知识需要。</li>
</ul>
<p>这三个问题的目的都是找到潜在的社群成员之间足够多的共同点，从而使得即将构建的知识社群能够创造足够凝聚成员的价值。<a href="value-creation.md">共同创造价值</a>是知识社群的最终目的。社群依靠它提供给成员的价值来推动，社群成员需要看到他们的热情怎样转变成有用的东西。</p>
<p>另一方面，启动社群不是从头开始。如果社群能够为其他人创造价值，那么一定已经存在围绕社群关注的领域形成网络的人。告诉他们你的社群能够就他们关注的领域提供足够多的价值，他们的知识和见解也能够在其中转变为实践。以开源共同体的潜在参与者来说，很少有人能够拒绝这样的诱惑。前提是你的社群真的对他们关注的领域有足够优质的实践。</p>
<p>我在一份规划开源社群的草案当中列出的一个关键问题，就是明确社群期望某种形式的参与，并思考可能的参与者现在在哪。书中写到，启动一个知识社群，需要同时发现你可以在什么基础上组建，并想象这个基础的潜力能够把你带到哪里。如果忽视了目前已经形成的网络，那么社群将很难吸引到最有可能成为早期参与者的人。但是如果只是考虑目前的网络，就不能超越个人的限制而为社群引入新的看法。</p>
<p>对于一个新的开源社群来说，一个常见的问题就是对参与者有过于苛刻的预期，并且在预期被屡次打破以后反转成一种彻底的不信任。实际上，哪怕是最有热情的参与者，也需要在持续的价值创造中找到和社群发展的共同利益。尤其是对于一个公司内部的软件团队，考虑突破组织边界以开源社群的方式运作的时候，不同背景带来的信息差是不可避免的。</p>
<p>这一方面需要建立起对话的渠道，就像我在 <a href="https://mp.weixin.qq.com/s/gOcQpXtUPqr1Ti7Hkyr_RQ">Open Discussion</a> 当中介绍的一样。另一方面，也需要认识到社群当中存在不同程度和不同类型的参与。</p>
<p>本书当中也采用了同心圆形式的社群引力模型，核心人员往往只占有 10% 左右，积极参与者也不过 20% 上下，剩下的七成左右的参与者，不会对社群的发展产生明显的促进。当然，这些比例和每个个体的行为是会动态流动的。社群的核心组对这样的情形应该有足够的预见性，避免对每个社群成员都予以核心成员的期望，或者按照市场营销的漏斗模型强迫每个成员选择向核心成员的“转化”或者离开。</p>
<p>这一阶段最重要的就是广泛的接触潜在成员和联系社群成员，通过人与人的联系和知识的交换以及实践的交流，定义出领域的范围、社群的主要意图和富有吸引力的切入点。如果社群能够度过这个阶段，往往能够发现潜在的社群协调员和思想领袖。</p>
<p>社群协调员会关注到社群新人的招募，会见潜在的成员，并联络核心成员以对齐社群对关键问题的认识和增强人际连接。思想领袖是社群关注的领域的专家，他们能够定义前沿问题，或者本身是具备丰富经验、德高望重的从业者。思想领袖的加入为社群提供了强有力的凝结核，试想 Ruby on Rails 的作者为 Ruby 社群带来了多少 web 开发者的参与。</p>
<p>书中分点罗列了这一阶段的典型工作计划，作为书评无法面面俱到的议论，但是仍然值得引用以作推荐。</p>
<ul>
<li>决定社群的主要意图</li>
<li>定义领域，识别有吸引力的问题</li>
<li>证明行动的理由</li>
<li>识别潜在的协调员和思想领袖</li>
<li>会见潜在成员</li>
<li>联系社群成员</li>
<li>发展社群的初步设计</li>
</ul>
<h3 id="知识社群的接合期"><a href="#知识社群的接合期" class="headerlink" title="知识社群的接合期"></a>知识社群的接合期</h3><blockquote>
<p>如果一个社群能够把对现状的良好理解和对未来发展方向的构想结合起来，它就已经具备条件，可以向接合期转变了。</p>
</blockquote>
<p>社群启动的时候，正如一家创业公司最初的商业计划，看起来往往是脆弱甚至站不住脚的。如果一个社群的领袖能够有信心地宣传社群的目标，介绍当前的情况，并说明如何从当前的情况逐步实现最终的目标，那么社群就可以开始举办各种活动和正式启动，扩大互相信任的社群成员的范围了。</p>
<ul>
<li>关键的领域问题是建立在这个领域内分享知识的价值。</li>
<li>关键的社群问题是充分发展关系和信任，使成员们能够讨论实践中真正复杂的问题。</li>
<li>关键的实践问题是明确哪些知识应该分享和怎样分享。</li>
</ul>
<p>信任在这一阶段极为重要，没有它，社群成员很难发现领域最重要的方面和社群真正的价值。虽然每个人都知道平等的交流，相互请教和寻求帮助能够提升自己和他人的知识水平，解决问题的成员也能积累自己的声誉和经验，但是缺乏信任的环境当中，大部分人会选择沉默或观望，而这种沉默和观望如果没有核心成员和积极的参与者以身作则破除不信任的印象，就会不断恶化，使得社群无法产生价值，进而失去由共同的目标的背景聚拢起来的早期成员。</p>
<p>建立信任，不仅仅是核心成员以身作则带来的形式上的安全感，还涉及到社群成员对社群目标的信任。前面提到，共同创造价值是所有社群的最终目的，不同社群只是在创造什么价值，以及如何创造价值上有所差异。如果不能在聚拢起早期成员之后，持续地回馈知识分享的价值和知识实践的价值，那么大部分参与者将会保持或者变成观望的状态，而不是付出足够的时间精力和热情投入到社群当中来。这也是我常说的开源参与者的思路是“谁赢他们帮谁”。</p>
<p>例如，《大教堂与集市》在总结 Linux 的成功经验的时候，就提到了 Linus 在早期开发的时候经常每天发布新的版本，新的版本当中包括了社群成员提交并被接受的补丁。这种直接回馈参与者，让他们看到自己的参与真的能够赢得回报，能够在社群当中建立起最朴素的信任关系。我在提及自己为什么参与 Perl 6 和 Apache Flink 这两个开源社群的时候，也强调了能够及时得到响应，解决自己的问题，并且提交的补丁能够被合并和发布，在社群当中看到我的努力帮到了更多的人，这种喜悦和认同感是联系社群成员的关键。</p>
<p>我和开源社群维护者交流的时候，一定会问的一个问题就是参与者为什么要进入你的社群，你能提供什么价值。尤其是作为一个知识社群，你在领域知识上的领先性体现在哪里？如果是一个自研项目开源的情况，往往项目的所有人都转过好几手，团队负责人只是接受命令开放源代码，那么他是很少考虑这个问题的。实际上，他本人可能都不太关注这个项目有什么用，为什么存在。</p>
<p>如果一个社群只是纯粹的复制别人做过的工作，那么顺着开源文化将会导向上游优先的结果。Apache 孵化器在接受项目的时候，就会衡量这个项目是否已经有同类已经存在，如果已经存在，那么加入这个社群，比起另起炉灶分裂是要更合理的。</p>
<blockquote>
<p>We prefer “Do NOT confuse users” because we accepted projects nearly doing the same thing. We always encourage more people could join together and build a more powerful project and community, rather than building several similar projects.</p>
</blockquote>
<p>同样，书中对接合期提供了一个典型的工作计划。这个计划的假设更多是在公司组织当中发起一个知识社群。</p>
<ul>
<li>向成员说明理由</li>
<li>启动社群</li>
<li>发起定期的社群活动</li>
<li>赋予社群协调员合法地位</li>
<li>在核心组成员之间建立联系</li>
<li>发现值得分享的想法、见解和实践</li>
<li>明智地整理文件</li>
<li>识别提供价值的机会</li>
<li>经理的介入</li>
</ul>
<h3 id="培育和维持知识社群"><a href="#培育和维持知识社群" class="headerlink" title="培育和维持知识社群"></a>培育和维持知识社群</h3><p>书中还介绍了知识社群的在启动和实现正常运转以后，走向成熟和管理的后续阶段。限于一篇书评能够关注到的重点有限，这里不做展开论述，只做重点罗列，以期能够激起各位阅读原版的兴趣。</p>
<p>成熟期的关键问题</p>
<ul>
<li>关键的领域问题是定义在组织中的角色以及与其他领域的关系。</li>
<li>关键的社群问题是管理社群的边界，因为这时的社群已经不仅仅是从事同一职业的朋友网络。在定义新的、更广阔的边界时，社群必须保证不脱离自己的核心目的。</li>
<li>关键的实践问题不再是简单地分享想法和见解，而是认真地组织和管理社群知识。随着社群形成更强的自我意识，核心成员开始认识到真正的前沿知识和知识社群的差距，感到需要更系统地定义社群的核心实践。</li>
</ul>
<p>管理期的关键问题</p>
<ul>
<li>关键的领域问题是保持领域的合理性，在组织中发出自己的声音。</li>
<li>关键的社群问题是保持有活力、吸引人的风格和关注点。</li>
<li>关键的实践问题是保持前沿地位。</li>
</ul>
<p>《知识社群》一书立论的基础跟开源共同体还是有所不同，它主要关注到企业应该如何发起、维持和培养知识社群，并从知识社群的蓬勃发展中受益。当然，相当一部分开源共同体也遵循这样的模式，由企业当中的最佳实践出发，以开放源代码和开源协同的方式跨越组织边界交流知识和实践以解决领域当中实际的问题。</p>
<p>本文主要的关注点还是在于社群本身的健康发展，原文关于如何将社群的价值和组织的价值结合起来，有更加详细的分点讨论。简而言之，就是社群作为一个独立的结构，如何找到它与公司组织利益的共同点，是它能够获取资源和赢得员工信任的关键。而如何找到社群发展与个人发展的共同点，则是持续吸引参与者的关键。</p>
<p>其中对于企业组织的价值，我在过去几天有过一段论述：</p>
<p>开源运营，对于企业来说有两个主要目的，一个是技术品牌的建立，一个以开源协同的方式打造成为行业标准的软件。这两个做好了，技术公司的技术知识优势，人才吸引力和留存率，还有成为标准以后的赢家通吃的价值，就非常可观了。</p>
<p>最大的挑战是如何协调公司的利益和社群的利益，使得两者尽量互不冲突的往前去走，相互能够合作。这个能够达成好的结果的前提是各方能够坦诚沟通，所以需要一个渠道和真正的去沟通。至于沟通下来仍有冲突的各种情况，做好预案就行了。</p>
<p>现在的开源处于一个相对好的时代，MongoDB 和 Elastic 当初面临的那种激烈冲突不太可能再次发生了。当然最终能够守住自己的利益，还是依赖自己强大的实力，不管是技术实力、谈判能力，还是其他。</p>
<p>我现在感觉到最难找的是有技术能力，且认同开源理念的团队。有技术实力，才能够在运营的时候依靠正道的方法掌握主动权。否则所谓的“运营”，就会变成为了技术不足的团队“善后”社群的技术挑战，而采取排他垄断的一个部门。这样就跟开源的理念背道而驰了。</p>
]]></content>
      <categories>
        <category>tison</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源之书</tag>
      </tags>
  </entry>
  <entry>
    <title>试论开源生态的经济模型</title>
    <url>/flossway/2022/02/05/economic-model-of-open-source-ecology/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>这是一个我一直想写，却一直没有想得非常清楚的课题。目标非常清楚：通过创建一种经济模型，来分析开源生态中的各种问题。</p>
<p>上一次在 CHAOSScast China 的一档<a href="http://xima.tv/1_fyIj3e?_sonic=0">播客节目</a>里，我们在讨论关于“指标”的问题。当时的话题是：自下而上的指标，还是自上而下的指标。</p>
<p>所谓自下而上，就是从开源世界原本就能观察到的各种行为入手，比如 star、fork、commit、PR 等等，然后通过某种计算，得到一个“指标”。这样做的问题是：意义不明。我们可以做各种加权计算，但是：为啥可以这么计算呢，无法说明。</p>
<span id="more"></span>

<p>所谓自上而下，就是从目标入手，我们希望考察一个开源项目，或者一个开源社区的某种活跃度，健康度，或者其他特征。然后去尝试构建一种计算方法：将各种行为拼接、计算。这样做的问题是：无从下手。因为我们可以提出无数的问题，但是答案太难找了。</p>
<p>关键在于：我们缺少一组明白无误的概念，并且这些概念能够组成一个可以理解并且切合实际的模型。更进一步的关键在于：我们对于开源软件，乃至对于开源的本质，缺乏理解。</p>
<h2 id="从劳动价值论入手开始思考"><a href="#从劳动价值论入手开始思考" class="headerlink" title="从劳动价值论入手开始思考"></a>从劳动价值论入手开始思考</h2><p>最近我刚刚读完一本很薄的小书《<a href="https://weread.qq.com/web/reader/45732a105cadfd45783b27a">解读劳动价值理论</a>》，总共只有5.9万字，却解释的非常清晰。简单的抄一下书：</p>
<p><strong>使用价值</strong>：一种劳动产品之所以能当做商品出售，是因为它具有一定的有用性。这种产品的有用性，即能满足人们某种需要的属性，马克思称之为商品的使用价值。</p>
<p><strong>交换价值</strong>：交换价值首先表现为一种使用价值同另一种使用价值相交换的量的关系或比例。</p>
<p><strong>交换价值（补充）</strong>：后来（货币时代）表现为商品与货币的交换关系，即一定数量的商品交换货币的多少。</p>
<p><strong>价值</strong>：凝结在商品中的抽象的人类劳动就是商品的价值，隐藏在商品交换价值中的共同的东西就是价值。</p>
<p>隐藏在商品交换关系或交换价值中的共同物——劳动量，就是商品的价值，而交换价值则是价值的表现形式。</p>
<p><strong>社会必要劳动时间</strong>：社会必要劳动时间是在现有的社会正常生产条件下，在社会平均的劳动熟练程度下制造某种使用价值所需要的劳动时间。</p>
<p>使用价值是商品的自然属性，交换价值是商品的社会属性。换句话说，交换价值即价格，它相对于价值来说，总是会上下略为浮动的。</p>
<p><strong>综上所述，使用价值表示商品有什么用，价值表示商品值多少钱，但这个“钱”不是指商品价格，而是凝结在商品中的人类劳动量。</strong></p>
<h2 id="通过劳动价值的系列概念，来思考软件的使用价值与价值"><a href="#通过劳动价值的系列概念，来思考软件的使用价值与价值" class="headerlink" title="通过劳动价值的系列概念，来思考软件的使用价值与价值"></a>通过劳动价值的系列概念，来思考软件的使用价值与价值</h2><p>在马克思的时代，他所讨论的商品，都是“实物形态”的，因此：所谓交换，要么是物物交换，要么是钱物交换。但是，到了商业软件时代，可以无限复制的软件（无论是源代码，还是可执行的软件），它的价值是什么呢？</p>
<p>另一方面，在讨论全世界所有的商品时，不同的商品的使用价值，其实是无法比较的。但是，同样作为软件，不同的软件的使用价值，是否可以互相比较呢？</p>
<p><strong>软件的本质</strong>，在CPU上执行的软件，本质上是在替代人类的脑力劳动。因此，软件的本质就是“人类脑力劳动能力的凝结”。</p>
<p>所以，<strong>软件的使用价值</strong>，在于能够替代多少人类的脑力劳动。因此，不同的软件的使用价值是可以互相比较的。</p>
<p>比如：一次100位整数乘以100位整数的乘法运算，人类的平均计算时间是多久？通过某种计算机计算，时间是多久？假设前者是1天，后者是0.1秒钟。那么，这就是这款乘法计算的软件，在一次运行之后，产生的价值。</p>
<p>再复杂一点的，一部3D动画片的计算机渲染，用计算机需要多少时间？耗费多少成本？用人工绘制，假设每一帧都是手绘，需要多少人，多少时间，耗费多少成本？那么，这就是3D图形渲染软件，在一部电影制作中，产生的价值。</p>
<p>基于我们对于软件本质的理解，一款软件的使用价值，其实取决于这款软件本身的替代能力，再乘以运行在多少台电脑（CPU）上，再乘以运行了多少次。</p>
<p>社会必要劳动时间，也是一种理论时间，按照我的理解，可以称之为：开发一款软件的平均成本。</p>
<p>于是：估算一款软件的价值，就可以换算为“估算一款软件的平均开发成本”。</p>
<p>这方面有两个参考，一个是过去经常听到的，基于功能点（<a href="https://en.wikipedia.org/wiki/Function_point">Function point</a>）的开发成本估算，另一种是我在适兕的新书《开源之迷》里看到的，构造性成本模型（Constructive Cost Model, <a href="https://en.wikipedia.org/wiki/COCOMO">COCOMO</a>）。</p>
<p>更多信息可以参考：<a href="https://en.wikipedia.org/wiki/Cost_estimation_in_software_engineering">Cost estimation in software engineering</a></p>
<p><strong>软件的交换价值</strong>，本质上并非金钱与软件的交换，而是金钱与使用权的交换。正因为软件的特殊性，因此：使用权的定价，也出现为比传统实体商品，更加复杂的情况。</p>
<h2 id="软件定价的两种模型"><a href="#软件定价的两种模型" class="headerlink" title="软件定价的两种模型"></a>软件定价的两种模型</h2><p>区分了使用价值与价值，我们就会发现，在软件领域，存在两种定价的模式。一种是基于使用价值定价，或者说基于使用情况定价。另一种则是基于价值来定价，或者说：基于社会必要劳动时间&#x2F;开发成本定价。</p>
<p>基于使用情况定价，其实就是卖拷贝。你们公司有100个人，每个人都用我的Office软件，那么就要出100份钱。你买了我的软件，运行在一百台服务器上，每台服务器有32个核，都应该算清楚，然后付钱。</p>
<p>基于开发成本定价，其实就是“定制化开发”。我提需求，你报成本，最后我按照一个合理的价格付钱，你有得赚，我也省得再自己开发了。</p>
<p>之所以存在两种定价模式，还是在于软件的可复制性。在实体商品的情况下，每生产一份商品，都需要付出一份劳动。因此：社会必要劳动时间–&gt;价值–&gt;使用价值，一个紧密连接的整体。而在数字商品的情况下，可以无限复制的软件&#x2F;数字商品，具有近乎无限可能性的使用价值。而其社会必要劳动时间，以及由此所确定的价值，却是有限的。</p>
<h2 id="现代软件生态中的使用价值"><a href="#现代软件生态中的使用价值" class="headerlink" title="现代软件生态中的使用价值"></a>现代软件生态中的使用价值</h2><p>在过去（几十年前），软件就是软件，软件复用还只一种理想。但是到了现在，现代编程语言的发展，诞生了“基于包管理系统”的软件开发复用模式。</p>
<p>于是，一个可以直接使用的最终软件与一个可以被复用的软件包，变成了两个概念。通常在一个最终软件里，都会包含（依赖）非常多的软件包，而一个较为流行的开源软件包，也会被很多不同的软件所采用（依赖）。</p>
<p>当我们想要估算一款开源软件包的使用价值时，会变得非常困难。A使用了B，B使用了C、D，D又使用了E。如果我们经过充分的统计，也许最终会搞清楚：E，同时被4种不同的软件，在不同情况的下使用了。</p>
<p>当然，我们还需要了解：这些不同的软件，运行在多少台电脑（CPU）上，以及运行了多少次。如果是商业软件，也许还能通过销售来掌握数据，但是对于开源软件，那就太难了。</p>
<h2 id="开源社区活跃度的意义？"><a href="#开源社区活跃度的意义？" class="headerlink" title="开源社区活跃度的意义？"></a>开源社区活跃度的意义？</h2><p>因为无法实际统计，一款开源软件的实际使用情况。我们只能借助一个假设：“越是用户众多的开源软件，开源社区的活跃度也会越高”。</p>
<p>当然：这样的假设会存在很多的不确定性。</p>
<ol>
<li>越是成熟的软件，用户虽多，但用户在社区的活跃度却可能越低</li>
<li>用户数量与使用数量的关系，取决于这款开源软件的应用领域，越是服务器端的，底层的软件，也是少数管理员，维护大量使用的实例</li>
<li>因为包依赖的关系，导致大量间接使用，却无法带来活跃度的提升</li>
</ol>
<p>所以，计算某一开源社区的活跃度，无法等价于“这个开源软件的使用价值”。</p>
<h2 id="价值流网络的意义"><a href="#价值流网络的意义" class="headerlink" title="价值流网络的意义"></a>价值流网络的意义</h2><p>赵生宇（Frank）最近写了三篇博客，也在讨论相关的话题。</p>
<ul>
<li><a href="http://blog.frankzhao.cn/how_to_measure_open_source_1">如何评价一个开源项目（一）——活跃度</a></li>
<li><a href="http://blog.frankzhao.cn/how_to_measure_open_source_2">如何评价一个开源项目（二）——协作影响力</a></li>
<li><a href="http://blog.frankzhao.cn/how_to_measure_open_source_3">如何评价一个开源项目（三）——价值流网络</a></li>
</ul>
<p>在我看来，价值流网络，其实就是在开源软件生态的复杂网络中，借助PageRank的算法，尽可能“推演”出一款开源软件的<strong>使用价值</strong>。</p>
<p>这当然是非常有价值的工作，但是这并没有解决开源软件的<strong>价值</strong>，或者说：<strong>社会必要劳动时间</strong>的计算问题。</p>
<h2 id="开源社区中的各种时间花费"><a href="#开源社区中的各种时间花费" class="headerlink" title="开源社区中的各种时间花费"></a>开源社区中的各种时间花费</h2><p>在开源社区中产生的各种行为，都会有其行为发起方与参与方，花费各自的时间。这些时间，有些是典型的软件开发过程中，正常花费。另外一些，则是社区里才会存在的行为与花费的时间。</p>
<p>比如：合理的提问，与正常的解答。如果能够将问答内容沉淀下来，本来就会节约后来者的时间。但是，如果有用户，毫无搜索与查找能力，直接提问，且强行占用他人的时间。这种行为，就会被社区所唾弃。因为，他浪费了整个社区的有效投入时间。</p>
<p>于是，在任何情况下，我们可以看到三个时间长度。</p>
<ul>
<li>T1 &#x3D; 当前版本，从头开发，所需的必要劳动时间。</li>
<li>T2 &#x3D; 当前版本，从一开始到现在，社区整体投入的劳动时间。</li>
<li>T3 &#x3D; 当前版本，从一个开始到现在，整个社区全体成员，所花费的时间</li>
</ul>
<p>通常 T1 &lt; T2 &lt; T3</p>
<p>我们可以将 T1&#x2F;T2 的比例，理解为社区的开发能力（少走弯路的能力）；T2&#x2F;T3 的比例，理解为社区的治理能力（少受打扰的能力）。当然还可以再引申：比如处理bug的时间，占开发时间的比例，代表着开源软件的质量。</p>
<h2 id="如何估算社区中的行为耗时"><a href="#如何估算社区中的行为耗时" class="headerlink" title="如何估算社区中的行为耗时"></a>如何估算社区中的行为耗时</h2><p>上一小节中，T1的时间看起来还比较容易估算。也许基于功能点，也许采用COCOMO。但是T2和T3呢？其实，我们应该能理解，越是复杂的行为，越是难以估算其平均耗时。而越是简单的行为，就越容易估算。</p>
<p>比如：写一个100万行代码的软件，社会必要劳动时间就很难估算。但是：写一个Class中的get&#x2F;set方法，耗时就非常容易估算。写100万字的一本小说，社会必要劳动时间会很难估算（起点中文网，也许已经有很准确的数据了），但是：写一个100行的文档，耗时就非常容易估算了。</p>
<p>同样的，我们在开源社区观察到的很多行为，无论是点赞，fork，创建issue，还是发起一个PR，都比完整的写一个软件，要简单很多。相对而言，估算其平均耗时，也会更加容易。</p>
<h2 id="开源社区活跃度的计算方法"><a href="#开源社区活跃度的计算方法" class="headerlink" title="开源社区活跃度的计算方法"></a>开源社区活跃度的计算方法</h2><p>如果我们将开源社区活跃度，定义为：一个开源社区，从全世界范围内，吸引到的总时间投入，再除以单位时间。较之纯粹主观的将各种行为加权运算，就会变得更加有解释力了。</p>
<p>从这个角度来看，star 的权重是秒级的，而 issue，PR 的权重，应该是分钟，甚至小时级的。这样计算活跃度，才会更加合理。</p>
<h2 id="开源社区活跃度的意义！"><a href="#开源社区活跃度的意义！" class="headerlink" title="开源社区活跃度的意义！"></a>开源社区活跃度的意义！</h2><p>我们可以认为，全人类的所有可使用的时间，是一个很大的常数。各个开源社区，当然还有互联网、SNS、短视频和购物平台，都在争夺这些时间与注意力。</p>
<p>全世界的程序员，能够投入写代码，写文档，回答问题，调试bug的总时间，其实是有限的。一个开源社区能够吸引到足够多的注意力与时间投入，就是其成功的基础保证。而软件&#x2F;互联网企业之间的开源竞争，其实就是在争夺程序员们的注意力，剩余时间。这也正是我在多年以前提到的关键点：《<a href="/thinking/it/2015/03/11/Open-source-attention-economy.html">开源项目也要讲注意力经济</a>》</p>
<h2 id="对于协作影响力的改进"><a href="#对于协作影响力的改进" class="headerlink" title="对于协作影响力的改进"></a>对于协作影响力的改进</h2><p>在 Frank 的博客中，假设开发者 d 在项目 p1 上活跃度为 Ad,p1，在项目 p2 上的活跃度为 Ad,p2，则该开发者对这两个项目协作关联度的贡献为 (Ad,p1 * Ad,p2)&#x2F;(Ad,p1 + Ad,p2)。</p>
<p>在问题部分，Frank 也写道：“开源协作网络的设计对活跃度虽然不敏感，但却有要求。即如果活跃度中引入 star 或 fork 这类低成本的行为，会导致大量项目之间产生连接关系，进而导致对项目类别判断的准确率下降。也就说目前聚类的效果很大程度上依赖于底层的活跃度设计。”</p>
<p>因此，我的建议就一条：采用基于时间的活跃度设计，来计算协作影响力。 :P</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的分析，我们基本上可以得到一个开源生态的经济模型的全貌了。</p>
<ul>
<li>社会必要劳动时间  –&gt;  特定版本的开发成本 –&gt; T1 –&gt; 特定版本的价值</li>
<li>社区总投入时间 –&gt; 开源社区活跃度 –&gt; T3 –&gt; 社区竞争力</li>
<li>基于时间投入的协作影响力 –&gt; 开源社区之间的相关度 –&gt; PageRank –&gt; 生态关联度</li>
<li>价值流网络 –&gt; 开源软件的生态总价值 –&gt; 使用价值</li>
</ul>
<p>基于以上的模型，我们也许可以展开进一步的分析了。</p>
]]></content>
      <categories>
        <category>庄表伟</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>高效参与开源的诀窍</title>
    <url>/flossway/2022/02/10/effective-open-source-participant/</url>
    <content><![CDATA[<p>大部分人参与开源社区会面临的一个巨大挑战，那就是缺乏时间。本文试图提供一种方式，帮助想要参与开源社区的同学高效利用有限的时间。</p>
<p>在一个开源社区里，maintainers 需要关注的范围比 contributors 要大得多。本文分别讨论这两类人群适用的参与开源社区的技巧，以减少过程中的摩擦，提高时间的利用率。</p>
<span id="more"></span>

<h2 id="Contributors"><a href="#Contributors" class="headerlink" title="Contributors"></a>Contributors</h2><h3 id="Join-the-community-and-lurk-first"><a href="#Join-the-community-and-lurk-first" class="headerlink" title="Join the community and lurk first"></a>Join the community and lurk first</h3><p>参与开源社区的第一步就是加入社区。加入社区的方式有很多，可以订阅邮件列表，关注开发活动，参与技术或非技术讨论，等等。很多希望参与开源社区的人迟迟迈不出第一步就是忽略了自己首先要加入社区，跟社区建立起联系。</p>
<p>一个典型的错误做法是完全不顾开源社区是开发开源项目的主体，一头钻进技术细节里，暗搓搓地做一个“大功能”，然后希望社区尽快合并这个补丁，让自己得到荣誉。</p>
<p>Linux Foundation 有一篇博文 <a href="https://www.linuxfoundation.org/tools/participating-in-open-source-communities/">Participating in Open Source Communities</a> 明确反对了这种做法。</p>
<blockquote>
<p>Some organizations make the mistake of developing big chunks of code in house and then dumping them into the open source project, which is almost never seen as a positive way to engage with the community. The reality is that open source projects can be complex, and what seems like an obvious change might have far reaching side effects in other parts of the project. Any significant change is likely to require some community discussion before it moves to implementation to make sure that there are no side effects and that the solution is aligned with the broader goals for the project. While you discuss it with the community, it can help to focus on the problem, rather than a specific solution, before you invest too much time in the creation of a body of code.</p>
</blockquote>
<p>一个现实的例子，前几天有人问我，自己做了一个 Flink StateBackend 的实现，提交给社区是不是就能当 PMC 了。这个问题属实把我整不会了。从来没有在社区当中亮相的人，突然出现并提出自己实现了一个“大功能”，在其他成员眼里跟民科没什么不同。绝大部分情况下，这种实现跟上游社区的开发节奏是脱节的，很难合回去。也就是说，闭门造车的形式自我感动地开发项目，即使花费了时间，大概率还是白忙一场。</p>
<p>刚开始接触 Flink 社区的时候，我就按照项目文档的提示订阅了 users 和 dev 两个邮件列表。实话说，最初的三个月，我基本看不懂他们在说什么。当时的我尽可能地读每一封邮件，从邮件里面引用的链接一个个点进去了解背景，混沌当中建立起对项目的初步印象。直到四个月后第一次提交代码，这个祛魅的过程才算完成。从此以后，我逐渐能够轻松地参与到技术讨论，也掌握了 review 的沟通习惯。</p>
<p>最近，我在跟人介绍 Engula 项目的时候，也是先发<a href="https://github.com/engula/engula/discussions">讨论区</a>和<a href="https://discord.gg/AN6vgVXaHC">聊天室</a>的链接。新成员可以阅读过往的讨论，挂在聊天室里，观察社区讨论问题和推进工作的方式，了解已有的设计实现和结论。参与闲聊或者回复感兴趣的话题，找到自己愿意投入的工作。只有这样，才能进一步深入参与开源社区，而不是接触了好几年，却始终迈不出第一步。</p>
<h3 id="Figure-out-what-you-care-about"><a href="#Figure-out-what-you-care-about" class="headerlink" title="Figure out what you care about"></a>Figure out what you care about</h3><p>要想利用有限的时间创造更多价值，最好的方法是找到一个感兴趣的问题，然后持续投入进去直到解决。</p>
<p>一个典型的错误做法是强迫自己做着不感兴趣的工作。这种情况下，由于内心是抗拒的，即使投入再多的时间，也几乎不会有产出。</p>
<p>可能有人会不理解，开源社区的 contributor 都是自愿参与，如果不想做某个工作，不是不做就可以了吗。其实不然，社区成员身处其中很容易感受到无形的社交压力。</p>
<p>一种情况是不懂得拒绝。知乎上有个问题，<a href="https://www.zhihu.com/question/475269038/answer/2045981148">如何优雅地拒绝开源项目的 PR 邀请</a>，讲的就是这种情况。我在回答里分享了一个自己拒绝 Flink 社区成员里的 PR 邀请的案例。另一种情况是错误估计难度，即自以为能搞定这个工作，做的过程里发现不对，又不好意思改口说自己搞不定。应对这些情况的方法非常简单，直截了当地说明情况即可，解放自己避免浪费时间。</p>
<p>另外一个难题是自己往往对比较有挑战性的工作感兴趣，但是从一个刚接触项目的 contributor 到能够完成一个复杂任务之间有一道坎。</p>
<p>要跨过这道坎，同样需要积极采取行动，而不要独自纠结。首先可以考虑从简单的工作入手，比如阅读项目文档时发现的拼写错误。一个简单的贡献能带你走完整个 contribution 流程。一回生二回熟，做其他有挑战性的工作也就不会在流程上踩坑。其次可以保持和 maintainers 的交流，以了解现有逻辑的设计背景和演进过程。只有对工作涉及的逻辑有充分的了解，才能写出高质量的代码。高质量的代码也意味着更少的返工和不必要的争论，也就避免了时间的浪费。</p>
<h3 id="Build-relationships"><a href="#Build-relationships" class="headerlink" title="Build relationships"></a>Build relationships</h3><p>随着参与的深入，总有你一个人无法完成的工作。开源协同的价值就在于跨越所属组织的边界合作开发项目。合作的基础是成员之间的信任，也就是良好的关系。</p>
<p>开源社区是围绕开源软件建立起来的。但是并不只有软件本身带来技术价值，人与人的连结带来认同感和归属感，这些也能满足社区成员的需要。此外，相互信任的基础能很大程度提升价值创造的效率，例如减少浪费在同步和对齐上的时间。因此，建立并保持与其他项目成员的关系至关重要。</p>
<p>做到这一点的方式就是充分的沟通。同样，这需要以开放的心态对待平时的交流。不要把所有事情都憋在心里。不要纠结于想清楚所有细节再开始沟通，其他成员一时间内往往没办法追上你所想的所有细节。我的建议是，当你有一个初步的想法，也做了力所能及的调研，就可以整理一下，发布到社区当中征求意见。</p>
<p>我给 Engula 项目做了一个<a href="https://github.com/engula/engula.github.io/pull/15">社区计划</a>。老实说，内容并不成熟，但是我一个人干想也得不出结论，所以在经过几轮自我 Review 以后，就先抛出来征求意见。另一个例子是 Engula 的 maintainer @huachaohuang 想为 contributor 提供开发文档，于是就发起了一个<a href="https://github.com/engula/engula/discussions/84">关于 Dev Guide 的讨论</a>。正好我对这个话题也早有想法，当我看到发出来的讨论以后，发现他也在关注这个话题。于是我花了一个小时把自己的想法写下来，经过讨论以后提 PR 推进主分支。</p>
<p>沟通协作的过程里冲突在所难免。我在好几个项目里都别人讨论甚至争论过很多次技术问题，给别人的行为提过意见，也夸赞过好的做法。开源社区解决冲突的方式比较朴素，一般是有话直说，尽量客观地达成共识，按照流程约定做出决策。不用整那么多弯弯绕浪费时间。</p>
<p>举一个现实的例子，曾经有人跟我抱怨提上去的 PR 被 maintainer 挑战了，问我应该怎么回复。怀疑 maintainer 是不是有偏见，抱怨很难跟 maintainer 沟通，大量的时间精力浪费在纠结这些臆想出来的问题，自然是筋疲力竭，感觉在开源社区里寸步难行。</p>
<h3 id="Talk-to-your-boss-and-choose-your-job"><a href="#Talk-to-your-boss-and-choose-your-job" class="headerlink" title="Talk to your boss, and choose your job"></a>Talk to your boss, and choose your job</h3><p>最后，关注到相当一部分 contributors 的公司员工的身份。这显然会影响到他们参与社区的动力和能力。</p>
<p>主要的挑战是，如果工作期间不允许参与开源社区，同时工作本身已经消耗了太多的时间精力，那么 contributors 对参与开源社区也只能是有心无力。这其实是很长一段时间里开源社区的参与在国内发展缓慢的原因。大量的开发者都在过度工作，下班只想躺平休息，没有动力再谈什么开源贡献。</p>
<p>不过，随着时间的发展，情况也在发生着变化。越来越多的公司采用更加灵活合理的工作时间，尤其是以研发为核心竞争力的公司。如果你所在的公司仍然要求超负荷工作，燃烧生命赚血汗钱，那么是时候找份新工作了。时代已经变了，就让这些公司被无情的淘汰吧。</p>
<p>另一个方向是考虑在工作期间参与开源社区。如果你确实喜欢某个开源项目，那么最佳策略就是找一份允许你全职投入这个项目的工作。这样的工作岗位如今并不少见。尤其是随着企业级解决方案越来越倾向于采用开源组件，企业对熟悉开源软件的人才的需求只会日益增加。如果找不到全职投入开源项目的工作，与之相关的工作也是备选方案。</p>
<p>不过，即使这份工作允许你全职投入开源项目，也并不意味着你能够参与开源社区。特别是当你的老板认为参与开源社区不能为公司创造价值的时候。面对这个问题，首先你可以问问你的老板，说不定他不这么觉得，那就省事儿了。如果你的老板确实难以理解，那你就得像兜售一个技术方案一样向他宣传参与开源社区的价值了。我在其他的文章里对这一点已经有不少讨论，你可以看看。</p>
<p>普适的时间管理手段这里就不展开介绍了，各种相关书籍和 GTD 方法论都很值得一看。</p>
<h2 id="Maintainers"><a href="#Maintainers" class="headerlink" title="Maintainers"></a>Maintainers</h2><h3 id="Nominate-new-maintainers-selectively"><a href="#Nominate-new-maintainers-selectively" class="headerlink" title="Nominate new maintainers selectively"></a>Nominate new maintainers selectively</h3><p>Maintainers 比起 contributors 需要关注的更多的事情。随着开源项目日渐复杂，开源社区逐渐成长，单靠一个人的力量很难处理好所有的事务。这个时候，就需要 maintainer 适时地发展项目维护的队伍。</p>
<p>首先需要理清 maintainer 头衔的定位。实际上，大部分项目的维护是个苦力活，而 maintainers 就是一群承担这些工作的社区成员。Maintainers 可能会拥有合并 PR 的权限，在社区治理中能投票做决策，确定项目发展的方向。但是，这种权限并非特权。在一个健康的社区里，任何社区成员都可以做技术讨论，也可以就社区发展话题提出自己的观点。对于技术观点，客观上更加合理的方案理应被采纳。对于社区发展话题，maintainers 也一定会考虑建设性的提议。</p>
<p>可能有不少人把成为 maintainer 当成参与开源社区的目标，这是很好的。如果你理解了 maintainer 的职责，通过 contribution 积累了足够的信誉，成为 maintainer 为开源社区服务，这个头衔是一个显式的认可。不过，大可不必过分纠结于 maintainer 头衔。这只是对 contribution 认可形式的其中一种，而不是唯一一种。</p>
<p>Maintainers 的职责并不轻松，所以 Python 社区和 Apache 软件基金会下的项目社区都会有一个询问 contributor 是否愿意成为 maintainer 的流程。也存在 contributor 拒绝邀请的情况，因为就像前面提到的，健康的开源社区里，只要提议是合理的，就能凭借其客观的优势胜出。成为 maintainer 并不意味着在方案选择上有特权。</p>
<p>对于 contributor 的感谢，也可以通过宣传渠道发布。比起一个模糊的 maintainer 头衔，作为技术人员，我会更在意这个人实际在开源社区里实际完成的事情。</p>
<p>基于上面的认识，我们引出下一个观点。Maintainers 发展新成员，必须是有选择性的。</p>
<p>这种选择性的主要依据是维护项目的需要，而不是追求数量或者过分在意 diversity 等等。这可以类比到开发软件的目的是提供技术价值，而不是代码行数或者所采用的编程语言的数量。</p>
<p>一个典型的错误案例是出于自己同时是公司员工的身份，被命令将 maintainers 的人数发展到某个数字。这种指标只关注数字而不关注具体的人，而且往往定得脱离实际。公司员工迫于指标压力很容易降低 maintainers 的标准，逮到一个算一个的凑人头，或者为了 diversity 对不同背景的 contributor 采取不同的标准。这样发展出来的 maintainers 不仅不能分担项目维护的职责，还很有可能因为不胜任而产生新的问题。</p>
<p>另一个典型的错误经常出现在个人项目上，当个人项目发展壮大，唯一的 maintainer 想要发展新成员时，很容易陷入到要找一个自己的分身的误区。 也就是说，新的 maintainer 必须和自己一样能够关注到项目的方方面面。这是不对的。没有两个人完全相同。只要一个 contributor 有足够的信誉，并且能在项目或社区的维护的某个方面上承担职责，他就是一个好的 maintainer 人选。</p>
<p>不过，这里讲到的信誉是一个非常主观的概念，提名 maintainer 的倾向每个项目也各有不同。</p>
<ul>
<li>Perl 社区最初由 Larry Wall 独裁。近年来，随着他逐渐淡出核心成员圈子，Perl 社区的治理实际上已经变成由 28 人组成的 core team 负责。</li>
<li>PostgreSQL 社区由 7 人组成的 core team 和 28 位 committers 处理所有工作。</li>
<li>ASF 治下的项目有一套比较固定的<a href="http://www.apache.org/foundation/how-it-works.html#roles">治理模型</a>。具体到每个项目，例如 <a href="https://pulsar.apache.org/en/contributing/#becoming-a-committer">Apache Pulsar</a> 和 <a href="https://flink.apache.org/contributing/how-to-contribute.html">Apache Flink</a> 会有自己具体的要求和倾向。</li>
<li>Spring Project 社区的 committers 都是 Pivotal 公司或 VMWare 公司的员工。但是它显然也是诞生于开源协同的作品。</li>
<li>Linux Kernel 基本上还是由 Linus 独裁。同时，海量的驱动和架构支持有各自的 maintainer 进行维护。参考 <a href="https://www.kernel.org/doc/html/latest/process/maintainers.html">Linux Kernel Maintainers 页面</a>。</li>
<li>Netty 社区没有明确的规则。Trustin Lee 发起项目并独自维护了三年。随后，Norman Maurer 和 Scott Mitchell 等少数几个人持续参与，成为 maintainer 并共同维护 Netty 项目至今。</li>
</ul>
<p>如果让我对 maintainer 提一个基础要求，我会希望他在项目或社区中做出了卓越的贡献，并且当前的 maintainers 团队乐于和他一起工作。</p>
<h3 id="Structure-processes"><a href="#Structure-processes" class="headerlink" title="Structure processes"></a>Structure processes</h3><p>除了增加项目维护的人员，另一个基本的减少时间浪费的手段就是结构化流程。我们分点介绍其内涵。</p>
<p><strong>第一点是直觉大于文档</strong>。对于托管在 GitHub 上的项目来说，help wanted 和 good first issue 标签是一个众所周知的约定。合理标记 issue 能让 contributor 按照过往的经验快速找到切入点。我在<a href="https://github.com/pingcap/community/issues/516">修订 TiDB 社区的治理方案</a>的时候，也是以跟 GitHub 开箱即用的功能亲和为主要目标之一。如果参与一个开源项目有太多新东西要学，那么 maintainers 就有的是要解释的东西了。大部分人效率最高的路径是完全凭直觉做事，并取得好的结果。所以如无必要，请勿设立复杂的规则。</p>
<p><strong>第二点是文档大于口述</strong>。直觉毕竟只能解决部分问题，对于特殊的或者需要强调的内容，明确记录下来作为文档绝对是个好主意。</p>
<p>不过文档首要的还不是记录流程，而是项目的目标或者叫定位。这是每个对项目感兴趣的人都会问的问题，高水平的 contributor 尤甚。他们不仅仅是想在开源社区里做简单的工作，更想成为一个伟大的或富有价值的项目的缔造者。如果你想为你的项目吸引到高水平的开发者，那么最好是确定一个清晰且令人振奋的目标，并将它展示在最显眼的地方。例如，Apache Flink 的定位是数据流上的有状态计算，其中有状态这点是开源世界里开创性的工作。例如，PostgreSQL 的定位是世界最先进的开源关系型数据库。例如，Elixir 语言的目标是构建可扩展和可维护的应用。</p>
<p>其次是约定俗成的文档，包括 README 和 CONTRIBUTING 等等。其中一般包含项目的简介，开始使用的方法，参与贡献的基本流程，和指向更多文档的链接。大部分 contributor 会尝试寻找和阅读这些文档。如果他们能从其中解决自己的问题，就不需要 maintainer 花时间说明了。至少，在有人提问的时候，直接发一个文档的链接，也能省不少事儿。</p>
<p>另一个值得强调的是 Code of Conduct 即行为准则。提名新的 maintainer 之前最好确保被提名人知悉和理解社区行为准则。行为准则通常是一些涉及平等、尊重和避免冒犯的原则。虽然大多数开源社区很少遇到严重违反行为准则的情况，但是 maintainers 应该对此保持敏感。这类问题一旦处理不当，很容易演变成政治斗争，甚至导致社区分裂或项目停摆。</p>
<p>最后是设计文档。Contributors 要深度参与技术贡献需要了解相关代码的设计背景和演进过程，设计文档就是最好的参考材料。良好的代码质量有助于避免 contributor 阅读源码时受挫，但是项目固有的复杂度还是需要设计文档来辅助解释。如果代码质量和设计文档都缺位，想要深度参与技术贡献的 contributor 就不得不指望 maintainer 花费大量的时间解释和指导了。这点对于 maintainer 自己也是一样的。当你想要做一个新的功能，如果没有好的技术文档，你也得懵圈，也得拉人反复对齐。</p>
<p><strong>第三点是避免私下讨论</strong>。有关项目和社区的讨论，唯一的信源应该是一个公开的渠道。例如，ASF 治下的项目要求所有有效的讨论都应该发生在邮件列表上。例如，大部分托管在 GitHub 上的项目隐含了讨论应该发生在 GitHub 平台上。社区成员可能还会通过其他的沟通渠道辅助交流，例如即时通信软件。但是这些辅助渠道的讨论需要被抄送到唯一信源上才实际生效。这样，contributor 才能在无需了解诸多渠道的前提下有能力获取所有有价值的信息。</p>
<p>这些公开讨论的内容以及表现出来的做事方式，就是社区当中的“活文档”。模仿是人类的天性，如果你希望别人遵循某种做事方式以减少冲突，那么最好以身作则，再带动更多的人跟随。前面讨论 contributor 的参与技巧时候说过，加入社区并首先观察别人是怎么做的，是一种避免浪费时间的好方法。那么与之相对的，maintainer 也要在项目维护和日常交流方面为此提供方便。</p>
<blockquote>
<p>Open Communications: as a virtual organization, the ASF requires all communications related to code and decision-making to be publicly accessible to ensure asynchronous collaboration, as necessitated by a globally-distributed community. <a href="https://www.apache.org/theapacheway/index.html">The Apache Way</a></p>
</blockquote>
<p><strong>第四点是考虑自动化</strong>。结构化的流程更容易自动化。当你的流程越来越结构化，那么是时候考虑自动化它了。显然，无需 maintainer 亲自动手的自动化流程能够减轻项目维护的压力。</p>
<p>同样，最好的自动化是符合直觉的。GitHub 平台提供了一系列自动化的支持。尤其是 <a href="https://github.com/features/actions">GitHub Actions</a> 发布以后，自动化的灵活性得到了进一步的提升。利用项目代码托管的平台提供的开箱即用的能力做自动化，能够最大程度的避免各种冲突。</p>
<p>自动化还应该建立在现有的成熟流程上，而不应该凭空生造一个流程。好的案例包括提交文档变更后自动部署文档页面，利用 merge bot 提高 pull requests review 和 merge 的效率等等。</p>
<p>其中，后者的采用是有两面性的。许多代码提交极其活跃的开源社区也仍然不需要引入自动化流程。当然，测试基本是自动化的，至少有脚本。不过 review 和 merge 还是可以人工完成的。我比较认同 merge bot 的地方是有些实现了排队合并功能以及 roll up 打包测试功能。这两个功能在保证合入主分支的代码是基于最新的主分支测试过的前提下，减少了需要进行测试的次数和人为协调的负担。但是，有些 merge bot 强制要求 review 和 merge 走非常严格的审批流程，把这个过程变得复杂不堪，这是我非常反对的。所以在引入 merge bot 之前，请确保你清楚地知道它如何改善协作效率，并保留回滚的能力。</p>
<p>另一个典型的错误案例是 stale bot 的自动关闭功能。真的，没人喜欢这个功能。开发者来到社区是为了和人建立联系，共同开发好的软件，而不是为了被机器人支配。应对 issue 或 PR 的积压问题，首先应该尽可能的及时处理。其次，大部分积压的 issue 是无效的内容，例如愿望清单和模糊的想法，这些只需要快速关闭即可。对于低优先级的 bug issue 的积压，既然问题是实际存在的，也不是 wontfix 的情形，凭什么关掉呢？如果当前的 maintainers 积极主动地处理 issue 和 PR 还是处理不过来，那么是时候寻找一个新的 maintainer 了。</p>
<blockquote>
<p>Users SHALL NOT log feature requests, ideas, suggestions, or any solutions to problems that are not explicitly documented and provable. <a href="https://zguide.zeromq.org/docs/chapter6/">The ZeroMQ Community</a></p>
</blockquote>
<p>流程自动化的标杆案例包括 <a href="https://github.com/kubernetes/test-infra/tree/master/prow">Kubernetes 社区</a>和 <a href="https://github.com/rust-lang/homu">Rust 社区</a>。在学习这两个社区的做法的时候，需要强调的是</p>
<ol>
<li>请关注这两个社区为流程自动化投入了多少人力。</li>
<li>请关注这两个社区是在什么时候引入了何种自动化逻辑。</li>
<li>请关注这两个社区的成员如何利用自动化流程。</li>
<li>请关注这两个社区在流程自动化上的异同。</li>
<li>请关注这两个社区推行流程自动化时的讨论，尤其是争议。</li>
<li>请勿货物崇拜，直接照抄它们的方案。否则你会死得很惨。</li>
</ol>
<p>既然 Rust 社区都不抄 Kubernetes 社区的方案，你为啥贸贸然就要抄？</p>
<h3 id="Manage-day-to-day-events"><a href="#Manage-day-to-day-events" class="headerlink" title="Manage day-to-day events"></a>Manage day-to-day events</h3><p>前面讲的是一些整体的做法，回到每个 maintainer 身上，实际的项目维护工作其实是日常事务。</p>
<p><strong>最常见的问题是开发的风险控制</strong>。开源项目通常会有自己的版本发布周期。有时候你希望下个版本能交付某几个关键功能或改进，而这些工作并不都是由你一个人完成。尤其是，你之所以想交付这些变更，是因为公司的要求，而开发团队包括并非公司员工的成员。这个时候就需要你做好项目的风险控制。</p>
<p>从公司员工的角度，我介绍过开源项目和商业公司独立运营的协同模型。运用这个模型，可以把商业上紧急的需求实现在 fork 仓库上，交付 hotfix 应对紧急情况。稍后，把改动 contribute back 到开源项目当中。这样就可以把商业要求和软件开发的工程要求隔离开来，避免向开源社区倾倒粗糙的补丁。<a href="https://github.com/streamnative/pulsar">Stream Native</a> 就在公司组织下有 Apache Pulsar 的 fork 仓库。我没有仔细研究过他们的具体做法，但是显然他们把一些公司关心的内容都放在 fork 仓库上记录。让上帝的归上帝，凯撒的归凯撒。这是好文明。</p>
<p>如果评估出来更合适的做法是把改动直接做在上游，那么我会建议在需要严格控制风险的情况下，直接由公司员工组成开发团队。当然，这些员工得靠自己的努力在开源社区当中赢得信誉，而不是只根据职位就被允许直接提交代码。如果同样的需求已经有其他团队在做，那么沟通就是必要的。如果信得过这个团队，保持关注并提供帮助即可。否则，可以尝试接管项目开发。Flink 社区的 <a href="https://issues.apache.org/jira/browse/FLINK-16654">FLIP-85</a> 提案是我和 Uber 的工程师分别独立提出的。经过几轮邮件列表上的讨论，最终由阿里的工程师主导实现。我参与了 review 和提供了部分参考实现。</p>
<p>上面讲的是一个好的案例。其实对于一个活跃的开源社区来说，PR 冲突的情况不会太少，种类也很多。</p>
<p>TiDB 社区发生过一起有名的 <a href="https://github.com/pingcap/tipb/pull/208">Xuanwo 事件</a>。完全相同的两个补丁，后提交的反而先被合入，导致先提交的被迫关闭。尤其是这个事件发生在并不繁忙的仓库上，并且两个补丁提交的时间相差一个月。这是一种非常典型的情况，需要 maintainers 保持对项目范围内发生的活动的关注。</p>
<p>Flink 社区有不少经典的乐子。<a href="https://issues.apache.org/jira/browse/FLINK-10052">FLINK-10052</a> 作为我从 2019 年就和 @lamberken 配合修复完成并经过生产环境验证的高严重性问题，在过去的三年里提交的三个补丁都因为缺乏响应最终没有合并。这也导致不少用户被迫手动打补丁。<a href="https://issues.apache.org/jira/browse/FLINK-11937">FLINK-11937</a> 是另一个例子。两家员工提供了不同的方案，其中一方缺少社区话语权，无力单独推进合并，另一方有能力但是无意推进，也不允许其他人推进。同样的案例还有 <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-44%3A+Support+Local+Aggregation+in+Flink">FLIP-44</a> 和 <a href="https://lists.apache.org/thread/snlsb5z9lcogdo7359dcwr4hn5qpymlo">Queryable State</a> 等等。</p>
<p>Flink 的例子其实证明了商业公司需要通过 fork 仓库的来应对商业需求。另外也可以看到这些讨论的发起人是如何被 stale bot 二次伤害的。</p>
<p>从开源协同的角度，contributor 不是程序，而是真实的人。上面提到的沟通手段，去掉公司员工的背景也同样适用。商业公司要做风险控制，开源社区也是一个组织，也可以做风险控制。只不过，开源社区是一个开放式组织。在这个环境下控制风险的手段不是管控，而是协同。前面讲到的文档和结构化的流程在这里同样可以起作用。信息在 contributor 之间自由流通，就不会有 FUD 产生的伤害。平时保持和其他 contributor 的联系，就能知道当前的工作最应该找谁一起做。</p>
<p>大部分情况下，contributor 是能够自我驱动和自我激励的。他们爆发出的创造力不可小觑。单就时间上的风险而言，如果你在开发文档里明确写下开发周期和发布模型，contributor 是乐于见到自己参与或主导开发的工作随新版本一起发布的。越是自我驱动参与开源社区的 contributor 越重视积累信誉。这个过程中，如果你作为 shepherd 指导或参与进去，只需要切实地关注和解决开发团队成员遇到的困难，并在需要时帮助他们管理好进度。</p>
<p>其他的沟通技巧和 maintainer 的最佳实践这里不再展开。Open Source Guides 提供了这个话题非常有益的补充，推荐延伸阅读。</p>
<ul>
<li><a href="https://opensource.guide/best-practices">Best Practices for Maintainers</a></li>
<li><a href="https://opensource.guide/leadership-and-governance">Leadership and Governance</a></li>
<li><a href="https://opensource.guide/building-community/#growing-your-community">Building Welcoming Communities</a></li>
</ul>
<h2 id="Have-fun-and-take-care-of-yourself"><a href="#Have-fun-and-take-care-of-yourself" class="headerlink" title="Have fun and take care of yourself"></a>Have fun and take care of yourself</h2><p>不论是 contributor 还是 maintainer 你都已经通过参与开源社区为社会创造出了价值。时不时想想你为什么要参与或维护这个项目，回顾这个项目已经取得的成就。你已经做得很好了。</p>
<p>软件都有自己的生命周期，开源软件也不例外。开源社区的工作也不是你生活的全部。如果你找到了新的乐趣，完全可以把项目交给其他 maintainers 维护，或者直接归档。如果开源项目的维护已经超出你的能力范围或者消耗了太多的时间精力，也可以休息一段时间甚至放弃对项目的维护。作为开源社区成员的你没有义务非得维护这个项目或者响应别人的请求。你把自己的工作自由的提供给其他人利用，已经创造了非常客观的价值。</p>
]]></content>
      <categories>
        <category>tison</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>从火山引擎开源违规谈企业开源策略</title>
    <url>/flossway/2022/02/17/enterprise-open-source-strategy/</url>
    <content><![CDATA[<p>就在距壬寅虎年春节前几天，开源圈又冒出了一个大瓜：字节跳动子公司火山引擎在其发布的一个产品中使用 Apache 软件基金会下的开源软件 Apache SkyWalking 时，没有遵循 Apache 2.0 协议的规定，导致直接违规。</p>
<p>在如今开源许可协议种类繁多，规则复杂的情况下，Apache 软件基金会被认为是一个对开源使用方相当友善的开源组织，而 Apache 2.0 协议也是所有开源协议中被认为是非常宽松的软件许可协议。一般使用方只要在使用这样的软件时做好声明就可以了。而这次 Apache SkyWalking 官方则直接曝出火山引擎在使用 Apache SkyWalking 期间不仅没有在他们的分发中保留 Apache 软件基金会的许可和 NOTICE 文件，还直接改变了所有使用到的软件包名称，并删除了 Apache 基金会的协议头。虽然鲁迅先生早说过一句令人警醒的话，“我向来不惮以最坏的恶意去推测国人”，然而，我还是不忍以任何恶意去揣测字节和火山引擎的行为，只是遗憾连如此顶流的科技巨头，对于开源治理也竟如此缺失。可见，开源普及的雄关漫道真如铁。</p>
<span id="more"></span>

<p>此事件一出， 也立刻引起开源圈人士各种议论纷纷，有呼吁 Apache 基金会拿起法律武器直接进行维权。火山引擎项目团队似乎也意识到了事件的严重性，随即在 1 月 30 日向 Apache SkyWalking 官方承认了自己的违规行为，并马上在产品中做出了修正更新：承认自己产品的分发是 Apache SkyWalking 的一个分叉版，同时补充加入了 Apache 2.0 协议文件和 NOTICE 文件，并恢复了相应文件的协议头。</p>
<p>确实，开源作为软件知识的自由共享方式，开源许可作为开源软件能确保按其开源创作者的共享意愿下来进行自由分享的协议规则，它的本意不是去挑起法律争端。如Apache 基金会的董事吴晟在其朋友圈表示，“很多人理解错了 SkyWalking 进行 License 维权的原因。我们不是慈善，但是 for public good，希望联合更多的人构建世界顶尖的软件。今天的时代，很多为了 marketing 为了营收做开源，但这不是 Apache 基金会和顶级项目的目标。”</p>
<p>吴晟在话语中表达了一个重要的观点：开源是公益，for public good, 但却也不会是无任何底线的慈善。这也正如我们 OpenTEKr 社区所一贯主张的“自由与规则同在，免费与商业共生”，这应该是开源的一个基本原则与共识。联想到之前另外一个科技巨头在开源项目运营时，完全忽视了开源中的程序员声誉文化的内涵，为了提高其开源项目的关注度而简单粗暴的用传统互联网营销中点赞送礼的方式来试图圈粉。这样那样因为对开源的误读误用而发生的笑话，实际上如出一辙。而随着开源在国内的进一步深入，如果没有正确的开源认知，无论科技大厂，还是一般企业，我相信这样的问题将绝不会是个别案例。 </p>
<p>就如，刚刚过去的中国足球在大年初一以 1:3 惨败给越南这样令人羞耻的失败类似。虽然给球迷们添堵，但当我们回过头去看下中国足球的基础教育情况，就拿我们近十四亿人中足球注册人口区区不到 2 万人的数量，和那些足球强国虽然绝对人口只有数千万，但动不动就是百万万人的足球注册人口相比，我们也就没有什么可以埋怨的，谁让我们如此无视足球的基础教育呢！开源亦如是，我们与其去批评和谴责这些企业所犯的低级错误，不如让我们去思考该如何帮助他们在企业中建立开源的认知，以及如何开展有效的开源治理的方法。</p>
<p>Linux 基金会在 2018 年时出过一份《企业开源实践指导》的手册。其当时就指出开源的渗透率在全球范围内已经从本世纪初的 20% 到 2018 年时的 85% 或更高的程度。事实上，无论身处哪个行业，或者开发什么样的产品或软件，你已经都可能高度依赖着各类开源软件。那么为更好的使用开源，对于企业开源实践是个无论是企业的管理着，研发部门负责人，或者是一个软件工程师，必须对开源做必要的了解和掌握。对于企业使用开源的好处已经毋庸讳言，但什么是企业用开源的正确姿势呢？那本手册里综合了近二十年以来国际上各大企业的开源实践，给出了很多极具参考价值的建议和操作指南。其中，最重要的一步就是企业在使用开源的过程中，建立与自己企业的发展相对应的开源策略。在该手册中定义了企业使用开源的四项策略：开源的消费策略，开源的参与策略，开源的贡献策略，开源的领导策略。</p>
<p>在这里，就结合该手册的内容，和各位读者普及一下这四项策略。</p>
<h2 id="开源的消费策略"><a href="#开源的消费策略" class="headerlink" title="开源的消费策略"></a>开源的消费策略</h2><p>大多数的企业一般是首先作为开源软件的使用方，即开源消费者，来和开源发生关系的。而企业作为开源消费者介入开源时，往往一开始是由企业内部的软件工程师驱动的，从在企业内部的软件系统设施或者自己的商业产品中使用到不同的开源技术以来提高自己的研发效率减少时间，降低研发成本，并提高产品差异化的能力。而企业在作为开源消费者并因此获得收益后，大多数的企业也会在很长的时间内保持在作为开源的消费方这一个定位上。那么，为了让自己在作为开源消费者时不发生错误，那么以下的几点就可以是作为企业开源消费策略的必要组成部分：</p>
<ul>
<li>建立一套开源使用的分类方案来指导关于使用哪些类别开源软件的业务决策。</li>
<li>建立一套开源合规体系来确保公司遵守履行使用开源软件的存在的所有义务。</li>
<li>建立一个开源审查委员会（Open Source Review Board, OSRB），作为公司开源活动的管理中心。如果条件不够，那么也至少在公司内部成立一个开源治理检查小组，</li>
<li>建立一个开源软件的使用流程以用于评估和批准开源使用情况。必要的话，可以部署一些自动化工作流程软件来管理。</li>
<li>建立一个和开源相关的年度预算制度，确保在工程、产品管理和法律方面的员工数量和基础设施方面定期进行一定的增量投资，以管理闭源和开源软件间的复杂组合。</li>
</ul>
<h2 id="开源的参与策略"><a href="#开源的参与策略" class="headerlink" title="开源的参与策略"></a>开源的参与策略</h2><p>由内部工程师驱动的企业开源消费也经常会由工程师进将此驱动进一步升级到企业以不同的形式或多或少参与到开源社区地活动中去，这是一种自下而上的企业自发地开源参与方式。而企业一旦也获得了在开源消费上的成功，那么企业也同时会自然而然地产生与开源社区更紧密地接触需要。如期望提高自己企业地知名度来从社区中招募了经验丰富的开发人员，以下是开源参与策略的必要组成部分：</p>
<ul>
<li>实时跟踪社区沟通平台，如聊天服务器，邮件列表，论坛和网站，以随时了解项目发展情况。</li>
<li>参加相关会议和聚会，与社区建立关系。</li>
<li>赞助项目活动和基金会，以提高社区内的知名度。</li>
<li>教育开发人员如何参与和参与开源项目</li>
</ul>
<h2 id="开源地贡献策略："><a href="#开源地贡献策略：" class="headerlink" title="开源地贡献策略："></a>开源地贡献策略：</h2><p>当企业意识到以基层工程师驱动的开源介入转化到以业务驱动的开源介入时，也就以为意味着企业在意识上准备好了从原先开源参与的基础上进行构建开源，并开始为开源项目贡献代码。那么对于企业而言，这是就需要有选择地与目标开源项目及相应的开源社区进行合作，以推动和实现公司对于开源的需求，并为战略性开源项目做出特定的贡献以获得额外的价值。因为代码贡献可以帮助塑造项目中满足公司需要的软件功能。以下几点就是这个策略阶段的考虑要点：</p>
<ul>
<li>任命一名项目负责人来领导开源策略及管理企业内部的开源小组。 </li>
<li>招募开源项目的贡献者和提交者去加入到对企业产品产生重要影响的开源社区。</li>
<li>部署开源协作工具以支持和管理开源使用和贡献。</li>
<li>有计划地增加一些开源开发人员资源。</li>
<li>在工程、产品管理和法律方面进行必要地增量投资，以参与现有的外部开源社区</li>
</ul>
<h2 id="开源的领导策略"><a href="#开源的领导策略" class="headerlink" title="开源的领导策略"></a>开源的领导策略</h2><p>在四大开源策略的最后一项就是领导策略。此策略应当建立此前所有的策略基础之上，而此时的企业也当是希望以利用新兴的技术趋势来建立自己领导地位为自己的业务战略。在现有的开源社区中，领导角色是通过与项目成员建立信任并保持对项目的高度持续贡献而获得的。这种情况需要对目标开源社区和联盟进行大量投资，以建立领导地位。它还需要在工程，产品管理和法律方面增加投入，以在外部社区和行业联盟中建立领导地位。以下是开源领导战略的必要组成部分：</p>
<ul>
<li>增加与目标开源社区的互动。 </li>
<li>有选择地采用一些开放标准来驱动公司的产品。 </li>
<li>开展与开源基金会的合作。</li>
<li>建立开源项目、开源组织或基金会。 </li>
<li>在工程、产品管理和法律方面进行增量投资，以与现有的外部社区互动。</li>
</ul>
<h2 id="动态的开源策略"><a href="#动态的开源策略" class="headerlink" title="动态的开源策略"></a>动态的开源策略</h2><p>在以上的开源软件方面谈到的消费，参与，贡献和领导力这四大策略中，每个策略也并不是孤立的，而是一系列连贯的阶梯型策略，每个策略的部署会要求企业在前面的策略中取得成功，而一个企业在这个阶梯上能走多远完全取决于企业自己。当从一个位置过渡到另一个位置时，它们通常会重叠。如前面谈到的，在开源的早期阶段（企业作为消费和参与者）主要是由工程驱动的，因为当工程师基于技术优势开始使用各种开源组件来加速开发并且参与选定的项目时，要么加入对话，要么做出小贡献。而随着时间的推移，这种使用在公司的高层中变得众所周知，当它获得牵引力时，这种参与就会在确定的战略下成为业务驱动的开源策略。 一些公司只是作为消费方实现他们的目标，并满足于保持这个水平，而有些公司则有不同的抱负，并希望在排名中推得更高，以获得一定的领导地位。每个企业完全可以根据自己的实际情况和开源发展的成熟度，最重要的是确定自己在梯子中的当前位置以及建立自己目标位置，并且构建好从当前位置移动到目标位置的蓝图路径</p>
<p>最后，始终不能忽略的一个关键是，在确定开源策略时，也有几个问题需要回答，并且应该越早回答越好。这些问题如下：开源要帮企业解决什么样的问题？我们参与或者建设什么样的开源项目社区？内部企业开源治理和内部企业文化是否能成为开源的赋能者？</p>
]]></content>
      <categories>
        <category>狄安</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源策略</tag>
        <tag>开源共同体</tag>
      </tags>
  </entry>
  <entry>
    <title>《开放式组织》书评</title>
    <url>/flossway/2022/02/10/open-organization/</url>
    <content><![CDATA[<p>本文部分启发自在 <a href="https://alc-beijing.github.io/alc-site/">ALC Beijing</a> 录制播客时讨论的内容，仅引用我个人的观点。播客内容应该近期会在前面链接的网站上发布。</p>
<p><a href="https://book.douban.com/subject/26894636">《开放式组织》</a>这本书单看它本身，讲的是红帽公司的组织管理经验。这是一个将商业价值建立在开源项目之上的公司审视公司内部的组织形式的著作，并且主要关注在红帽这个案例上。这样，不管是在经验的普遍性上，还是在开放式组织这种形式跨越组织，尤其是建立商业公司和开源社区之间的联系这方面的讨论上，都有所欠缺。</p>
<p>从理论到实践，从企业审视内部到跨越组织边界，连接商业公司和开源社区，这样一个广义上的“开放式组织”阅读主题，我推荐以下几本书共读。</p>
<ul>
<li><a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a></li>
<li><a href="https://book.douban.com/subject/34834429/">《协同》</a></li>
<li><a href="https://book.douban.com/subject/26976995/">《社区运营的艺术》</a></li>
<li><a href="https://book.douban.com/subject/35531548/">《用户共创》</a></li>
</ul>
<p>《企业的人性面》我认为是《开放式组织》背后的理论基础，成书于 1960 年，历久弥新。《协同》是国内学者关注“内破部门墙，外拓企业边界”的研究跨越组织边界合作的当代著作。《社区运营的艺术》和《用户共创》均出自 Ubuntu 社区经理 Jono Bacon 之手，讨论了开源社区这一开放式组织的运行方式与最佳实践。这几本书都是阅读《开放式组织》的有益补充。</p>
<span id="more"></span>

<h2 id="为什么要理解开放式组织这种形式？"><a href="#为什么要理解开放式组织这种形式？" class="headerlink" title="为什么要理解开放式组织这种形式？"></a>为什么要理解开放式组织这种形式？</h2><p>这个问题也是计划中的“开源协同”系列文章里会展开讨论的问题，这里做简略的回答。这个问题在《开放式组织》里没有直接讨论，而是作为已知假设。然而，这个问题却是想在国内推行开放式组织这种管理模式首先要回答的问题。</p>
<p>本书涉及这个问题的一句话</p>
<blockquote>
<p>我们发现，开发开源软件的最佳方法同样也非常适用于管理整个公司。</p>
</blockquote>
<p>也就是说，开放式组织就是开发开源软件时协调开发团队或者说开源社区的组织管理手段。我喜欢将开放式组织这种组织管理手段简称为“开源协同”。开源软件在开源协同的生产力加持下，在不同领域攻城略地，击溃了专有软件的统治。如果企业想要基于开源软件打造商业价值，那么它就必须了解开源软件。在这种情况下，传统的控制管理模型会导致企业和开源社区激烈的摩擦。要想获得生产力的提升，企业必须成为开放式组织。</p>
<p>这种摩擦来自于时代发展带来的对于组织管理的颠覆。《协同》当中提到的“强个体的价值崛起”，以及《用户共创》当中提到的“社区成员为社区工作，而不是为商业公司工作”都是这一点的佐证。如今，开源社区有能力依靠其同侪社区当中强大的个体打造高价值的软件，其力量足以支持 Linux 赢下服务端操作系统，支持 Rust 成为富有竞争力的系统级编程语言，支持 PostgreSQL 成为世界前列的数据库软件。开源社区及其成员无需依赖于企业尤其是单一企业的控制而生存。因此，他们可以坚持为社区工作，而不是为商业公司工作。</p>
<p>在这种情况下，如果坚持传统的控制管理模型，试图将社区成员驯化成免费劳动力，必将破坏可能的跨越组织边界的合作的信任基石，回退到商业公司雇佣一批员工实现一个本身即是产品的软件。前文说到，开源软件得益于开源协同的生产力加持，正在不同领域中击溃专有软件的统治。在这一背景下，仍然希望聚集起一批员工写出足以媲美开源软件的专有软件，是不太现实的。绝大部分情况下，你无法聚拢起比拟开源社区的专家团队。<a href="https://book.douban.com/subject/2265341/">《维基经济学》</a>当中提到，“唯一有资质做出新发现的人可能在他的组织范围之外”，这将是越来越常见的情况。</p>
<p>《开放式组织》并没有过多的讲这部分内容，因为红帽已经走过了这个阶段。要想跟 Linux 社区达成最好的协同，乃至形成某种意义上的“原厂”品牌，必须以开放式组织的形式运作。本书更多的是讲在已经要运行一个开放式组织的前提下，如何发挥这一组织形式最大的生产力。其实作者 Jim 已经在第一章中提到过，他一开始也试图以传统的控制管理模型来管理红帽公司，但是开放式组织的力量已经不可阻挡，正如开源社区这一开放式组织的力量也不会以商业公司的意志为转移一样。于是他开始学习、理解并运用开放式组织的形式来释放红帽公司员工的生产力。</p>
<h2 id="如何点燃工作热情？"><a href="#如何点燃工作热情？" class="headerlink" title="如何点燃工作热情？"></a>如何点燃工作热情？</h2><p>开放式组织具体的管理策略和<a href="https://book.douban.com/subject/30356081/">《奈飞文化手册》</a>所介绍的准则多有共通之处，其理论基础则都很可能来自《企业的人性面》当中提到的企业管理的 Y 理论。</p>
<p>点燃工作热情是这类组织要面临的第一个挑战。《奈飞文化手册》写到，“成年人最渴望的奖励，就是成功”。《开放式组织》在本章中也提到</p>
<blockquote>
<p>你需要一个能让大家时刻铭记在心的目标，而不只是停留在追求利润这个层面上，这是吸引顶尖人才的唯一方法。</p>
</blockquote>
<p>如果利用马斯洛的需求层次理论来分析，这是要求激发员工对尊重和自我实现的需要的追求。传统的控制管理模型压抑员工的安全需要乃至生理需要的满足，主要使用金钱和职位来激励员工，但是这种激励不能持续。不仅仅是因为员工得到满足后激励作用就会消失，更因为商业公司无法持续用金钱和职位激励每一位员工。与之相反，开放式组织不会压迫员工的生理需要和安全需要，而是激发新时代高价值的强个体的热忱和渴望，也即点燃工作热情来发掘被压抑而无法释放的生产力。</p>
<p>值得注意的是，本章名为“构建充满热情的工作环境”，对于如何做到上面提到的激发热忱和渴望，书中的论调也是</p>
<blockquote>
<p>对于管理者而言，如今最重要的任务就是建立一个启发思考、培育积极的投入精神，并且推崇无限热情、想象力和主动性的工作环境。</p>
</blockquote>
<p>也就是说，组织管理要做的是构建环境。虽然需要关注个体在环境中的发挥来校正对环境状况的认识，但也不用过分纠结某一个人的热情是否点燃。一个人没有热情，是很难点燃出热情的，根本就不可燃。管理者能做的是破除环境当中压抑了人原本的热情的限制条件，释放原本就存在的工作热情。</p>
<p>这一思路也出现在《企业的人性面》当中，书中对比纠结个体，试图利用一致的模式创造标准化人才的“制造”手段，提出了人才的“栽培”方法。</p>
<blockquote>
<p>个人将成长为他可以成为的样子，只要为他们创造适当的成长环境。</p>
</blockquote>
<p>也就是说，开放式组织基于对个人价值的认可和个人能力的信任，致力于创造出能点燃员工工作热情，积极投入工作的环境。</p>
<h2 id="如何提高员工的参与度？"><a href="#如何提高员工的参与度？" class="headerlink" title="如何提高员工的参与度？"></a>如何提高员工的参与度？</h2><p>首先自己要参与，而不是作为一个局外人去提升其他员工的参与度。《开放式组织》当中写到，“想要得到，就先要付出”，就是对每个希望提高员工参与的成员提出的建议。</p>
<p>《企业的人性面》当中花了一整章的篇幅讨论何为参与以及如何参与。根本是要树立诚信，员工能够真正地参与到事务活动和决策中来，整个旅程没有破坏安全感和信任的坏例子。</p>
<p>假模假样的号召参与，实际并不采纳意见等仍然遵循控制管理模型的做法，并不能够瞒天过海，反而是失掉员工的信任，进而整个提高参与度的努力都会失败。</p>
<h2 id="何为精英领导制？"><a href="#何为精英领导制？" class="headerlink" title="何为精英领导制？"></a>何为精英领导制？</h2><p>本书的第四章、第五章和第六章都聚焦在如何做决策这个议题上，而开放式组织从开源社区当中借鉴到的决策方式，自然是精英领导制。</p>
<p>《开放式组织》很有价值的一点在于对比了精英制度和民主制度，并明确地指出了精英制度不同于民主制度的要点。</p>
<blockquote>
<p>精英制度是指根据提出的最佳方案做决定的方式；才能是选择的唯一标准，而非地位、偏见或特权。在一个公民公司里，最优的行动方案是在公开、充分、信息量足够的辩论之后胜出的方案。精英就是每一个有思想、有知识的人，每一个在真正理解之后得出的好想法都会得到重视。毫无才华的吹牛皮之人不会得到尊重。实施了精英制度之后，参与性民主必然将权利转移至最低一级人群的说法也将不攻自破。</p>
</blockquote>
<p>许多开源社区做得不好的一点，就是太强调平等乃至于变成平均主义。其实社区成员积累社会资本，应该是一个 earn authority 的过程，积极主动的 contribution 获得别人的尊重，而不是凑人头投票决策。</p>
<p>Linus 多次表示自己他只以技术论高低，PostgreSQL 社区和 Apache 社区推选新的 Committer 时是核心成员闭门会决议后公示，都是反对民粹的体现。开源社区的公平是基于 contribution 赢得权威的精英领导制，遵守 earn authority by contribution, not by position 的原则。近年来不少开源社区的维护者不堪民粹道德绑架的压力频频爆出“开源世界的暗面”，就是没有形成健康的精英领导制的认知。</p>
<p><a href="https://www.bilibili.com/video/BV1454y1E7xp">Linus Torvalds: 我不在乎政治正确，我只在乎技术本身</a></p>
<p><a href="https://www.bilibili.com/video/BV19f4y1F7QQ">荣耀还是负担？开源大神们居然这么累</a></p>
<h2 id="开放式组织是不是未来唯一的或者最高级的组织形式？"><a href="#开放式组织是不是未来唯一的或者最高级的组织形式？" class="headerlink" title="开放式组织是不是未来唯一的或者最高级的组织形式？"></a>开放式组织是不是未来唯一的或者最高级的组织形式？</h2><p>最后，我想讨论一下这个问题。因为在我讨论开源项目和开放式组织的话题的时候，经常会有人举单一反例，以开源项目和开放式组织如果不是普适的那么就是错的这种无厘头逻辑，来搅乱讨论的氛围。</p>
<p>对于这个问题的答案，我只能说不是。开放式组织是一种选择。控制管理模型也有适合它的军队或教会等组织，前面已经讨论过需要理解开放式组织的原因。现在仍然有专有软件领跑某个领域，仍然有技术领先的源码可得的专有软件开放 API 或允许带有限制的修改，如果你的商业模式适用于这些形式，大可不必采用开放式组织的形式。</p>
<p>但是，软件复杂度将不断提高，基础软件乃至其部分再也无法仅凭一个人或一个公司的全体员工来编写。开源社区这种跨越组织边界，凝聚不同背景专家共同开发的形式，将会生产出高质量的软件，成为事实标准并击溃专有软件。这样的事情正在持续不断的发生。所以至少这个领域的企业，应当理解和采取开放式组织的形式。这种形式也是当前开源社区唯一成功的组织形式。</p>
<h2 id="红帽公司的管理原则"><a href="#红帽公司的管理原则" class="headerlink" title="红帽公司的管理原则"></a>红帽公司的管理原则</h2><ol>
<li>因为想来，所以加入我们。</li>
<li>贡献是决定性因素，但不是交换条件。</li>
<li>不论由谁提出，只要是最好的想法就能胜出。</li>
<li>我们鼓励并且期待开放、坦诚、充满热情的辩论。</li>
<li>我们欢迎反馈意见，本着“早发行，勤发行”的精神做出改变。</li>
</ol>
]]></content>
      <categories>
        <category>tison</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源之书</tag>
        <tag>组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>企业如何实践开源协同</title>
    <url>/flossway/2022/02/10/open-source-collaboration-enterprise-perspective/</url>
    <content><![CDATA[<p>随着开源概念的红火，越来越多的企业将内部项目公开托管到 GitHub 等平台，也有越来越多依托开源项目建立起来的企业。对于这些企业来说，它们的目标不只是开放项目源代码，更希望能够形成开源共同体，打造围绕项目的软件生态。</p>
<p>然而，其中大部分项目由于成员背景的单一性，最终都终结于仅源码可得的形态。对于这些新兴项目来说，初始成员从属于同一企业是既定事实。在这样的前提下，企业应该如何实践开源协同，形成开源共同体呢？</p>
<span id="more"></span>

<h2 id="共享工作流"><a href="#共享工作流" class="headerlink" title="共享工作流"></a>共享工作流</h2><p>从开发者的角度出发，根本问题是要共享工作流。共享工作流，即项目开发的核心流程只有一套，所有 contributor 无论背景都基于这套核心流程工作。</p>
<p>对于企业内部项目开放源代码的情况，要做到这一点并不容易。项目往往在企业内部已经有一套成熟的工作流。如果在设计开源方案的时候，没有把共享工作流考虑在内，即使代码公开，大部分开发流程也会保持在企业内部。如果 contributor 不是企业员工，则根本无法参与。</p>
<h3 id="Case-Study-OceanBase"><a href="#Case-Study-OceanBase" class="headerlink" title="Case Study: OceanBase"></a>Case Study: OceanBase</h3><p>这个问题的典型案例是 <a href="https://github.com/oceanbase/oceanbase">OceanBase</a> 项目。</p>
<p>OceanBase 项目的源代码托管在 GitHub 和 Gitee 两个平台上，同时接受问题报告和补丁提交。通常来说，一个项目只会有唯一的问题报告和补丁提交方式。例如，Linux 采用 Bugzilla 记录问题，邮件列表提交和评审补丁。GitHub 上有 Linux 的镜像，但是是只读的。其他的例子包括 GCC 和 PostgreSQL 等，都会有唯一的工作流，其他代码仓库只是镜像。OceanBase 两边都接受问题报告和补丁提交，反而是对两边的反馈都不重视。</p>
<p>可以猜测，它的核心流程既不是 GitHub 上的工作流，也不是 Gitee 上的，而是企业内部的工作流。这种情况下，能从开放可参与的平台上提交的大概率就只有简单的拼写错误或者代码重构补丁。因为即使是资深的开发者，缺少必要的信息和充分的讨论，也无法更进一步参与。实际情况也是如此，内部的活动别说讨论和设计文档，就连提交都不是实时同步的。此外，项目在两个平台上的活动，基本只有一名维护者出面在处理。</p>
<p>企业开放内部项目源代码，允许任何人学习和使用，是有社会价值的。但是内外两套工作流，甚至开放可参与的工作流只是个添头，那就不可能形成开源共同体。如果这就是预期的目标，那倒也没事。只是对于辛苦应付这些留下来的缺口进来的简单补丁的维护者来说，他是否会觉得这只是另一种值班呢？无论如何，工作流的统一都有助于减少损耗。不管是干脆只保留内部工作流，托管平台上的所有活动都没有回应保证，还是尝试融合到开放工作流，真正做到开源协同，都比牺牲一部分人，做一些创造出来的边缘工作要好。</p>
<h3 id="Case-Study-Apache-InLong-incubating"><a href="#Case-Study-Apache-InLong-incubating" class="headerlink" title="Case Study: Apache InLong (incubating)"></a>Case Study: Apache InLong (incubating)</h3><p>致力于融合到开放工作流的典型案例是 <a href="https://github.com/apache/incubator-inlong">Apache InLong (incubating)</a> 项目。这个项目是由腾讯捐赠给 Apache 软件基金会的数据流处理平台。</p>
<p>在项目开放初期，也存在只有内部工作流的情形。不过得益于主要维护者的软件工程经验，在明确项目要以开源协同的方式运作以后，经过对维护两套开发流程弊端的分析，得出了要融合工作流的结论。既然是开源协同，那么融合的工作流就是共享工作流了。</p>
<p>一段时间的改造后，原先内部工作流的核心流程被迁移到共享工作流当中，包括问题报告、补丁提交和版本发布。原先内部工作流服务于企业需求的部分则基于共享工作流构建。</p>
<p>企业内部仍然有用户问题报告，但是归结到项目本身缺陷的问题，会脱敏之后报告到 GitHub Issue 上。为了解决紧急问题，企业内部的 fork 版本仍然会打临时补丁快速上线，但是救火之后正式修复的补丁会以 contributing back 的形式提交到开源项目上。最后是版本发布。一开始，只有内部项目在发版。开放源代码之后，就有两个同类项目要分开发版。经过一系列的改进，主要是问题报告和补丁提交的及时同步，最终两个项目能够以较小的同步开销同时发版。换句话说，GitHub 上托管的版本，就是企业内部使用的版本。企业内部可能有一些临时补丁，但是并不构成一个差异化内部版本，并且这些补丁是积极地被推进 contributing back 上游的。</p>
<p>可以看到，确定开源协同开发项目的方向后，共享工作流不是形式主义，而是能切实提高软件工程效率和减少摩擦的方案。</p>
<p>对于企业本身依托开源项目建立的情况，要维持共享工作流也存在很多挑战。这些挑战大多出自一个原因，那就是最佳实践的匮乏导致节外生枝的私下讨论。</p>
<h3 id="Case-Study-TiDB"><a href="#Case-Study-TiDB" class="headerlink" title="Case Study: TiDB"></a>Case Study: TiDB</h3><p><a href="https://github.com/pingcap/tidb/tree/master/docs/design">TiDB</a> 的代码仓库中有专门存放设计文档的目录。理论上，新功能，行为变更，以及其他重要改动，都需要一个设计文档。</p>
<p>我们可以从设计文档的时间线看出这一工作流的变迁。</p>
<ul>
<li>2018 年下半年，共 17 份设计文档。</li>
<li>2019 年全年，共 6 份设计文档。</li>
<li>2020 年全年，共 13 份设计文档。</li>
<li>2021 年至今，共 19 份设计文档。</li>
</ul>
<p>从另一个维度看，2019 年 5 月到 10 月，2020 年 10 月到次年 2 月，一共将近一年的时间里，项目没有提出过任何设计文档。</p>
<p>那么，TiDB 项目在此期间是停止开发了吗？没有。它一直以每个工作日合并 10 个 PR 以上的开发速度在前进。在此期间关于功能设计的讨论，其实是转进了企业的即时通讯工具或内部文档当中了。我们可以看几个例子。</p>
<ul>
<li><a href="https://github.com/tikv/tikv/issues/10540">Raft Async IO</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/25970">SPM Enhancement</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/26085">Cardinality Estimation Enhancement</a></li>
</ul>
<p>这几个功能并不是没有设计，而是只在小范围内通过中文文档做出设计，就开始实现。甚至在 Cardinality Estimation Enhancement 的例子当中，以为 contributor 想了解功能设计和背景，被 assignee 以时间紧迫为由回绝。虽然 assignee 承诺会在完成后进一步披露消息，但是却没了下文。</p>
<ul>
<li><a href="https://internals.tidb.io/t/topic/372/7">Announcing remove required integration test check when merge pr</a></li>
</ul>
<p>另一个例子是 pull request 上的检查项变更。不仅整个过程是在企业内部决策后直接在开源项目上上线，共同体内的其他成员一无所知，而且对于 bad case 的处理依赖于企业内部的群聊，让人摸不着头脑。</p>
<p>其实这些案例，我相信相关成员并不是刻意要伤害开源共同体。设计和开发的需求是天然存在的，持续集成的改动也不是不能做，但是实际推动落实的成员，缺乏开源共同体当中工作的经验，难以站在一家企业之上的视角，以合理的方式开展工作，才导致了这些实际伤害了开源共同体的做法。</p>
<p>我在这两个方向都做过一些改良的工作。对于设计文档，我发起了一个 Public Design 的讨论，并且推动了几个重大改动的公开设计。在此过程中和复数的开发者沟通了公开设计的技巧，以及在此前提下如何高效地推进重要改动的落实。实际上，公开设计并不会损失效率。因为并不是内部讨论完成后拿出来公示，而是从一开始就放在公开渠道讨论。既然是开源协同，补丁提交本身也是公开的，这些材料有什么好隐藏的呢？相反，因为得到了潜在的更多反馈，能够在设计等早期阶段避免缺陷，反而公开设计是更加高效的手段。</p>
<ul>
<li><a href="https://internals.tidb.io/t/topic/399">Discuss: Public Design</a></li>
<li><a href="https://github.com/tikv/pd/issues/3839">Tracking issue for Region Label Feature</a></li>
<li><a href="https://github.com/tikv/rfcs/pull/67">RFC: Substitute RocksDB write stall</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/26020">Tracking issue for heuristic rules enhancement for index selection</a></li>
</ul>
<p>对于持续集成，企业内部把研发和工程效能分成两个竖井，又把开源共同体仅关联到研发的工作上去，是这个问题的根源。组织结构问题不好解，只能先改变工程效能团队的员工的认知。当他以开源共同体成员的身份变更项目基础设施的时候，也通过提交议题，达成共识后实施的工作流来推进。实际上，这样改变以后，关注到项目功能开发的成员与维护基础设施的成员更能坦诚的交换意见，避免意料之外的改变激发矛盾。</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/issues/28947">Integrate UT coverage with CI pipeline</a></li>
</ul>
<h3 id="Case-Study-Taichi"><a href="#Case-Study-Taichi" class="headerlink" title="Case Study: Taichi"></a>Case Study: Taichi</h3><p><a href="https://github.com/taichi-dev/taichi">Taichi</a> 是一个主要面向计算机图形学的并行编程框架，由胡渊鸣博士发明。去年，他作为联合创始人创立了太极图形公司来支持项目的发展。</p>
<p>项目早期基本是胡老师一个人的工作。开放源代码并有 contributor 加入后，画风是这样的。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/1836">[async] Implement basic StateFlowGraph</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/479">Allow ti test_python to take in individual test files</a></li>
</ul>
<p>这两个 pull request 的三位参与者，彼时分别在美国波士顿、日本东京和中国上海。当时也没有成立公司，更不谈有企业内部的即时通讯工具或文档空间。所以你可以看到所有必要的讨论都发生在 GitHub 平台上。</p>
<p>时间拉回到现在，部分项目的开发仍然是有迹可循的。比如有个置顶的 <a href="https://github.com/taichi-dev/taichi/issues/2398">RoadMap</a> 作为当前正在投入的工作的地图，比如 <a href="https://github.com/taichi-dev/taichi/issues/3301">Taichi 编译器前端类型检查</a>有个 tracking issue 来记录工作。</p>
<p>不过，也会出现我在昨天看到的无描述 4000 行改动无评论合并的案例。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/3567">[Mesh] The ti.Mesh class &amp; mesh-for loop implementation</a></li>
</ul>
<p>经过社交媒体的传播，目前这个 pull request 更新了部分描述。其实是一个学术研究相关的功能，在发出论文后希望 contributing back 到上游。由于变更较为复杂，早期设计出于研究原因不便公开，加上持续集成流水线的效率问题，所以采用了一步到位的合并方案。代码 review 私下发生在提交之前。</p>
<p>那么，这些信息昨天凌晨看到的我能够知道吗？答案是不能。</p>
<p>其实这种提交一个大改动的案例并不少见。Apache Flink 项目曾经多次发生过这样的事情，包括 2014 年 7 月合并 streaming 的原型，2019 年合并阿里巴巴内部版本 BLINK 等等。项目接受来自企业或学术团体的 contribution 是很正常的，其他开源项目也有研究室基于项目做出优化策略后 contributing back 的案例。</p>
<ul>
<li><a href="https://lists.apache.org/thread/mc4622swvv1y4dbty5x20rlh3whdjst5">[DISCUSS] A strategy for merging the Blink enhancements</a></li>
<li><a href="https://lists.apache.org/thread/mn1nf4p11t054zmhdglorjt40xoyz7wv">[ANNOUNCE] Contributing Alibaba’s Blink</a></li>
</ul>
<p>开源共同体接受 contribution 的标准做法仍然是公开讨论。只需要说明这件事情，解答潜在的疑问之后决定接受或拒绝 contribution 即可。如果 ti.Mesh 的研究结果是以这样的形式合并到代码仓库的，我想在一开始我就不会有疑惑和疑惑导致的误会。另一方面，公开讨论和 contribute 对开源项目也是一种保护。Apache 项目在接收重要 contribution 时都会考虑引入一个<a href="http://incubator.apache.org/ip-clearance/">知识产权清理</a>流程，确保接收 contribution 不会引入知识产权相关的争端。</p>
<p>Taichi 项目当中缺乏背景信息的还有这些例子。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/3538">[bug] Remove fallback in C++ code</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/3433">[gui] Show f16 image as f32.</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/3279">[Lang] Support more SNode trees for LLVM backends</a></li>
</ul>
<p>当然，必须说明的是 Taichi 项目的大部分 pull request 是有背景信息的。上面这些案例的参与者，我想也不是刻意隐藏信息，而是成立公司之后，自然地在线下或者内部平台讨论。既然已经通过私下讨论得出结论，再刻意搬到 GitHub 上反而就是低效的。对于具备项目假设 contributor 应该有的知识就能理解的补丁，也不需要做作的讨论。</p>
<p>要想避免因为已经私下讨论得出结论，从而把共同工作流的一部分切换成内部工作流的情况，应该从两个方面入手。</p>
<p>第一个是在确定开源协同开发项目的方向后，所有技术讨论都以 GitHub 平台的内容为唯一信源。私下讨论是无法禁止的，只能从技术领袖开始以身作则，推动公开讨论。其实对于大部分企业员工来说，在哪讨论并不重要。真正让他们转向私下讨论的原因，是在 GitHub 上的评论得不到回复，而钉一下或者内部文档 at 有奇效。值得一提的是，Taichi 也有我曾经到的 TiDB 的问题，那就是没有一个活跃的开放式讨论渠道，即没有邮件列表的替代品。有个 Discourse 论坛，但是是面向中文用户而不是全球开发者的。开通了 GitHub Discussion 功能，但是只有唯一一个版本发布的公告。</p>
<p>第二个是作为共同体的领袖，应当积极寻找不同背景的参与者。如果已经形成了私下讨论的习惯，仅仅要求员工改变习惯是很难有效的。因为公开讨论的主要原因，是为了和企业以外的 contributor 交流，以获得有意义的输入和提高生产力。如果员工发现换个地方发言，得到的回应还是同事的回应，并且 GitHub 上的评论还是得不到即时的回复，这件事就推不下去。</p>
<p>前面的例子提到过，当 Taichi 的主要开发者天各一方，没有成立公司之前，这种沟通是自然而然的。实际上，Linux 和 Apache Httpd 也是这样的。除了邮件列表，Linus 很难找到另一个渠道收获他所需要的反馈。Apache Httpd 的早期成员一开始就是在邮件列表上沟通的。只有实际存在组织以外的高水平参与者，开源协同的最佳实践才有意义。对于企业员工来说，也才有直接合理的理由不在内部讨论。毕竟就某个特定的问题，他更希望听一听那个不同背景的共同体成员的意见。</p>
<h2 id="招募新成员"><a href="#招募新成员" class="headerlink" title="招募新成员"></a>招募新成员</h2><p>寻找不同背景的参与者，其实就是作为共同体的领袖为共同体招募新成员。这是企业实践开源协同的另一个难题。除了为企业招募以外，应该如何为共同体招募呢？</p>
<h3 id="End-user"><a href="#End-user" class="headerlink" title="End user"></a>End user</h3><p>第一个要讨论的是用户。不过，用户是开源协同之外的内容。商业产品同样需要自己的用户。大部分用户也不会关心软件是如何实现的。</p>
<p>所以，要讨论用户，其实是要驳斥一些错误的观念。用户能够为你提供使用反馈，能够通过付费或捐赠支持项目开发人员持续投入，但是期待从用户群体中大规模地发现核心 contributor 则是不切实际的。</p>
<p>我听到过很多项目领袖跟我说，他的项目是独特的，因为不像大数据项目那样，用户本身也是开发者。它可能是一个数据库。哎呀，用户都是 DBA 或者数据分析师，根本不知道数据库怎么实现的嘛。它可能是一个机器学习框架。哎呀，用户都只会操作 Python 接口，根本搞不来核心 C++ 代码。</p>
<p>那我就想问了，你咋不去找那些就做数据库的人，就搞机器学习框架的人呢？你给团队招聘的时候知道找这些人，怎么到了给共同体招募新成员，眼里就只看到用户了。</p>
<p>其实我也可以理解。因为开源协同不够普及，大部分人提到 open-source 这个概念，第一印象还是一个市场营销的手段。或者提到“运营开源社区”，就把用户社区那些已有经验都搬过来。在这样的认识下 open-source community 就是开源社区，而不是开源共同体。其中“我们”是唯一的开发者，是懂行的。其他人是只会小修小补的爱好者，或者干脆啥也不懂的用户。</p>
<p>这个误区有点像思维定式。你现在要找的是有能力开发项目的参与者，那就去对应的群体里找就可以了。</p>
<p>当然，如果你就想做用户社区，就没打算搞开源协同，也是一种选择。对于这类需求，我建议研究 MongoDB 的做法。它们搞得挺好，这里就不展开了。</p>
<h3 id="Ecosystem"><a href="#Ecosystem" class="headerlink" title="Ecosystem"></a>Ecosystem</h3><p>抛开用户不谈，开源共同体当中的 contributor 还可以进一步细分。其中有一类 contributor 关注生态互连，另一类关注项目的核心逻辑。</p>
<p>如果项目提供了足够多的扩展点，或者策略替换机制，那么关注生态互连的 contributor 就能够快速参与进来。</p>
<p>例如，Flink&#x2F;Spark&#x2F;Presto 等项目都设计了 connector 机制，连来连去就能创造出大量的工作。例如，几乎所有项目都可以搞多语言 SDK 玩玩。TiKV 就有不少于五种编程语言的客户端实现。例如，PostgreSQL 提供 FDW 机制，不仅支持连接外部数据源，更暴露了参与 planning 阶段的计算下推接口。例如，Linux 其实也有丰富的扩展机制，支持多种架构和驱动就是一个例子。</p>
<p>上面这些都是项目本身的机制，更广泛的生态还包括解决方案的整合。例如，从 Netty 的角度看，Flink 就是它的生态的一部分。从 Flink 的角度看，serverless 技术栈 StateFun 又是它的生态的一部分。经常听 database 的开发者说自己的软件直面终端用户，但是其实就互联网业务开发者来说，中间是隔了一层 ORM 框架的。哪怕是数据分析师，大概率也隔了一层可视化框架。另外，数据的同步和搬迁也是应用设计不可缺少的一部分，这就是各种中间件能发挥作用的地方了。</p>
<p>总之，这类 contributor 还可以再细分。一类是关注项目提供的机制替换实现的，大部分可以从有可能提供实现的项目开发者当中寻找。例如项目的部署机制希望支持 Kubernetes 环境，那找一个热衷于写 Kubernetes Operator 或者刚学会跃跃欲试的开发者参与，就很有可能产生正面效果。另一类是关注项目整合形成用户解决方案的。实际上，项目开发者最终基于项目实现盈利，往往就是以某种解决方案出现。只要你发挥想象力，生态整合的可能性就是个乘法，不愁找不到参与者。即使是核心逻辑被单一企业掌控的 MongoDB 项目，其生态也是非常繁荣的。</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>当然，项目的核心逻辑也是非常重要的。如果项目本身不够坚挺，那么就不会有用户使用，也无法激起 contributor 连接生态的动力。</p>
<p>项目的核心逻辑是一个项目的主要价值。这些逻辑通常由项目的初始成员定义。在企业主导项目的情况下，这些初始成员往往背景单一。同时，出于传统组织观念的影响，初始成员往往以企业当中的项目团队作为自我认同，团队等同于项目，也因此将核心逻辑的开发层层“保护”在看不见的高墙之内。</p>
<p>以项目团队作为自我认同，无怪乎招募新成员的时候，自我认知自动翻译成团队招聘，而想不到还有其他可能性。</p>
<p>反观成功的开源项目，数据湖项目 <a href="http://hudi.apache.org/">Apache Hudi</a> 由 Uber 捐赠给 Apache 软件基金会，在项目快速发展过程中吸引到了阿里巴巴和 T3 出行等企业的员工的参与，并吸纳了上述企业背景的开发者作为项目 PMC 成员。对于后续参与的企业的员工来说，他们在企业当中虽然也有项目团队，但是显然不会觉得项目归企业内的项目团队所有。对于 Uber 来说，来自其他企业的核心 contributor 的声音也不可忽视。这样，Apache Hudi 成功建立了一个开源共同体。</p>
<p>要想为项目招募开发核心逻辑的参与者，我觉得应该做到以下三点。</p>
<p><strong>第一点是改变认知</strong>。上面已经介绍了错误认知的危害和避免错误认知的最终形态。我把这种正确的认知称为“开发者的两顶帽子”。同一个开发者，既是开源共同体的参与者，也是企业的员工。这两个身份虽然从属于同一个人，但是却有着不同的诉求。只有区分开这些不同的诉求，一部分是开源共同体的目标，一部分是企业基于开源项目创造商业价值的目标，才能避免认知混乱导致人为制造出参与的高墙。</p>
<p><strong>第二点是公开讨论</strong>。前面讨论的很详细了，这里再补充一个点。当你真的身处一个开源共同体当中，不做公开讨论才是奇怪的。例如 Apache Hudi 的例子，如果 T3 出行的开发者想要实现某个功能，除了公开讨论寻求共识，别无他法。</p>
<p>公开讨论还有一个额外的好处，那就是方便引用。不少基于开源项目建立起来的企业，运营人员整天发愁哪里有技术内容可以发布，写技术文章好像变成了一个苦差事。其实技术话题公开讨论，天然的就有高质量的内容可以推送，其中悬而未决的议题，也是 contributor 参与的绝佳切入点。例如 <a href="https://twitter.com/engulaio">Engula</a> 项目在社交媒体的输出，基本就是设计文档或者开放式讨论里值得发布的内容。</p>
<p><strong>最后一点是积极招募</strong>。前面分析 Taichi 的例子也提到过，认知改变的假设需要多样化的开源共同体成员来验证，保持公开讨论的做法也需要不同背景的 contributor 参与。除了公开讨论能够吸引到潜在的参与者，积极招募更意味着共同体的领袖要主动思考谁是你要找的人。</p>
<p>对于每个项目来说，这个问题的答案都不一样。但是认为这个问题没有答案，或者说人才都在企业当中了，则是一种傲慢。</p>
<p>同样举数据库的例子，哪怕你有 Oracle 那么大，世界上也还有相当一批人在开发 PostgreSQL 等项目。这些人并不是一辈子就做这一件事的。只要你的项目足够有趣，他们就有可能投入。</p>
<p>另一方面，泛泛而谈数据库这样一个复杂的领域其实是一种懒惰。既然复杂的项目本身会分模块开发，为什么在招募新成员的时候就只想着完全理解整个领域的人呢？如果项目的并发设计不佳，只要是精通该语言并发编程的专家，愿意 contribute 做改进，你管他懂不懂数据库的专业概念。醉心于编译器前端的开发者，也许能解决 SQL Parser 当中经年的性能问题。进入 Apache 孵化器的项目的导师，往往也不是项目所在领域的专家，甚至不是开发者，但是他们能够帮助项目以 Apache 的方式建立起开源共同体。</p>
<p>以这样的方式去寻找潜在的开发核心逻辑的成员，相信你的视野会更加广阔。</p>
<p>其实，这才是“开源共同体”的含义。不止于项目，也不是社区居委会，而是围绕开源项目的发展，基于对项目的认同，形成的多层次合作共同体。</p>
]]></content>
      <categories>
        <category>tison</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>《大教堂与集市》书评</title>
    <url>/flossway/2022/02/10/the-cathedral-and-the-bazaar/</url>
    <content><![CDATA[<p>历时五天，我总算把<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>这本经典的开源文化著作认真读了一遍，真是酣畅淋漓。</p>
<p>本书是作者 Eric S. Raymond 的一个博客文集，其中最著名的一篇就是《大教堂与集市》，其他几篇分别是《黑客圈简史》《开垦心智层》《魔法锅》和《黑客的反击》。最有价值的是《大教堂与集市》和《开垦心智层》两章，系统解释了开源软件是如何生产的，开源开发的优势在哪，开源软件的传承是如何做到的。《魔法锅》解答了一些常见的关于开源软件使用价值和销售价值的问题，但是受限于时代背景，对商业化的讨论局限在夸大使用价值的部分，不能很好的指导基于开源软件提供软件服务的商业模式。</p>
<span id="more"></span>

<p>在进入具体的内容讨论之前，必须着重提到译者卫剑钒对中译本创造的价值。翻译是对原内容的二次创作，软件开发领域外文著作众多，大部分译本都让原文表意有明显的损失。卫剑钒翻译的《大教堂与集市》，阮一峰翻译的<a href="https://book.douban.com/subject/6021440/">《黑客与画家》</a>，以及云风翻译的<a href="https://book.douban.com/subject/35006892/">《程序员修炼之道（第二版）》</a>是我近一年来读过的本领域最佳译作。</p>
<h2 id="开源协同的优势"><a href="#开源协同的优势" class="headerlink" title="开源协同的优势"></a>开源协同的优势</h2><p>《大教堂与集市》一章主要讲的就是开源协同的优势。集市模式就是开源协同的模式，本章的要点在于论证这种模式能够生产出高水平的软件，以至于超过任何商业公司闭门造车的软件。原文的论述重点在同行评审的价值，辅以拥有用户的重要性，落点在如何以集市模式领导开源项目。出于讨论流畅性的考虑，我把前两点的顺序调换然后展开。</p>
<h3 id="拥有用户"><a href="#拥有用户" class="headerlink" title="拥有用户"></a>拥有用户</h3><p>对于任何软件来说，获取用户都是一个艰难的生存挑战，持续的用户反馈能够帮助软件不断修正前进方向，没有用户也即意味着软件的死亡。开源软件能够在早期发展阶段吸引到足够的注意力和用户。</p>
<p>一种形式是如原文作者继承 popclient 项目，从而直接继承其用户群。这在商业公司开发的软件当中是不容易做到的，因为涉及到专有软件的所有权转移，总是非常的繁琐且挫败的。大部分商业公司开发的软件，一旦因为种种原因不再维护，往往无法为人所继承而是彻底死亡。</p>
<p>因此，如今的用户对全新的专有软件往往抱有很强的怀疑态度。例如，最近一段时间迸发出来的新兴数据库软件，如果我无法获得它的源码，那么我如何能够自由地探索它呢？成熟的闭源商业软件辅以用户手册或许没有这个烦恼，但是软件的更替是不可避免的，新兴软件刚出世时，往往欠缺文档，功能不全，只有阅读源码甚至加以修改才堪堪能用。这种情况下，开源软件不是比闭源软件更好的问题，而是只有开源软件才能生存下来的问题。</p>
<p>此外，围绕开源软件或软件群形成的开源共同体有内部共通的价值观。如果你制作了一个新的开源软件，在潜在的用户群组里发帖介绍自己是不会被排斥的，如果软件质量不错，还会得到用户的自发传播。例如，我在 GitHub DCO App 异常期间，顺手开发了一个基于 GitHub Actions 的方案并在原 issue 下<a href="https://github.com/probot/dco/issues/162#issuecomment-942926111">评论介绍自己的解决方案</a>。没有回复会认为这是恶意竞争，而是出于解决问题的群策群力。又例如，Engula 项目开发过程中，向 Rust Community 和其他相关主题的资深开源开发者均寻求过意见和建议，其中认可 Engula 项目价值的人，就会自发的传播它。这对于商业软件来说是不可想象的，如果上面的行为替换成一个闭源商业软件，则参与者会认为你是一个销售人员而不是黑客同行，并且对一个完全黑盒的全新解决方案兴趣寥寥。</p>
<p>最后，开源软件不会将自己的用户局限在销售关系以内，这往往能保证软件开发者有更强的主导能力，按照符合软件工程的方式开发高质量软件，而不是在需求爆发的压力下将软件绑定在单一用户的需求上。</p>
<h3 id="同行评审"><a href="#同行评审" class="headerlink" title="同行评审"></a>同行评审</h3><p>同行评审是原文论述的重点，实际上，集市模式的核心价值就在于跨越组织边界的独立的同行评审验证设计和保证正确性。原文将其称为“Linus 定律”，即</p>
<blockquote>
<p>如果有足够多的 beta 测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</p>
</blockquote>
<p>不过针对这个定律有两点需要解释。</p>
<p>第一点是它所强调的是独立的同行评审实施的简单性和有效性，而不是单纯的“人多力量大”。</p>
<p>开源开发的价值之一就是源代码公开使得任何人都可以分析代码逻辑以定位问题。时至今日，传统的研发组织仍然把开发人员和测试人员区分成两个竖井，测试人员几乎只能完成黑盒测试。可想而知，缺乏分析的现象型 bug 报告往往需要耗费开发人员相当多的时间重新验证、复现和定位。如果让对源代码一无所知的测试人员为 bug 定级，则两类人员之间的冲突会更加尖锐。</p>
<p>开源开发打破了这种困境。由于大家都有真实的源码，开发者和测试者很容易发展出一个共享的表达模式并进行有效的交流。一个现象型 bug 报告和一个直接关联到源码的分析型bug报告，对开发者解决问题的帮助简直是天壤之别。Linus 定律建立在开源开发的基础上，强调的是拥有源码以后加入新的眼睛的成本不在包含商业公司管控带来的限制和摩擦，从而能够从基数足够大的同行评审当中获取高价值的报告。</p>
<p>原文引用<a href="https://book.douban.com/subject/26358448/">《人月神话》</a>的 Brook 定律，提到随着开发人员数目的增长，项目复杂度和沟通成本按人数的平方增加，而工作成果只会呈线性增长。对于这个论点，原文作者是认同的。但是，开源项目所采用的沟通方式，区分成少部分核心开发人员与由 beta 测试者和潜在的贡献者组成的外围人员。外围开发者实际工作在分散而并行的子任务上，他们之间几乎不交流；代码修改和bug报告都会流向核心团队，只有在那个小的核心团队里才会有 Brooks 开销。</p>
<p>这揭示了开源开发的精英领导制内核，也解释了 Linus 定律虽然常被简化成“只要眼睛多，bug 容易捉”，但是却不是简单的“人多力量大”。</p>
<p>第二点是开源软件当中出现 bug 是正常的。这一点过于天经地义以至于当我发现我需要强调它的时候有些震惊。近年来出现的“心脏滴血”和前几天的 Log4Shell 漏洞，导致部分声音认为开源项目的使用是有风险的。</p>
<p>对此，我只能说，这当然啊！软件有 bug 不是正常的事儿么？开源开发不是银弹，任何复杂的软件都会有 bug 存在。Linus 定律成立的案例 Linux 是在高速发展的过程中保持了相对稳定的质量，而不是从来没有 bug 出现。如果你认为开源软件有不可承受的风险，最佳做法是参与其中对它做出改良。</p>
<p>此外，开源软件的许可证往往附带了免责声明，也即这个软件的源代码就这样（AS IS）给你了，没有任何保证（WITHOUT WARRANTIES）。在应用当中整合开源软件之后，保证应用的正确运行与安全性是应用开发者的责任。开源软件会因为安全问题损失声誉，因此作者会尽力提高安全性和正确性，并辅以相应的测试验证，但是这些都是尽力而为，没有保证。</p>
<h3 id="集市模式"><a href="#集市模式" class="headerlink" title="集市模式"></a>集市模式</h3><p>《大教堂与集市》一章的落点在如何以集市模式领导开源项目，这种模式相较传统的管理架构有何不同。</p>
<p>其中很多原则和技巧不是开源特有的，并通过敏捷等理念渗透到商业公司的软件开发当中。例如，“好的软件作品，往往源自开发者的个人需要”，“早发布，常发布，倾听用户的反馈”，以及“想出好主意是好事，从你的用户那里发现好主意也是好事”等等。</p>
<p>其中最重要的一点是关于发布的。开发者在需求列表不能调整和最后期限不能拖延的双重要求下，会完全顾不上质量，整个工作很可能会变成一团乱麻。Linux 通过发布两种不同类型的版本，各自宽松其中一个要求来保证软件质量和进度的协调。</p>
<blockquote>
<p>一种办法是保持最后期限不变而让需求列表灵活一些，允许某些到最后期限时仍未完成的需求被舍弃，这基本上就是“稳定版”核心采取的策略。 Alan Cox（稳定版核心的维护人）以相当规律的时间间隔将核心发布，但并不保证某个特定bug何时被修复，也不保证实验版中的某个特性何时会搬到稳定版中。</p>
<p>另一个办法是设定好想要的需求列表，并在其完成时发布，这基本上是“实验版”核心的策略。 De Marco 和 Lister 引用研究结果，指出这个进度策略即是“好了告诉我”，这不仅能够保证最高质量，而且就平均而言，与“保守”或“激进”的进度安排相比，它的交付时间更短。</p>
</blockquote>
<p>对于与传统的管理架构比较的部分，其理论基础可以参考<a href="https://book.douban.com/subject/26894636">《开放式组织》</a>与<a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a>相关的论述。概括地说，开源的方式给予开发者足够的自由，以吸引高水平的黑客自发地创造价值。这种超越了对安全需要乃至生理需要的追求的模式，激发的是参与者对社会需要和自我实现需要的热忱。</p>
<p>在这里，没有预设的团队和资源，不需要在办公室环境下吞并其他团队的资源或者对其他团队的进攻做出防守。开源开发者是志愿者，是因为兴趣和能力自主选择的，他们会把自己的资源带到工作中，而不需要关心团队之间的领土争端和倾轧。</p>
<p>在这里，参与者凭借其创造的价值赢得权威。也就是说，最有才华的人能够对项目的发展做出最合适的决定。这不同于雇佣关系下被强制调配的人与项目之间的关系，而是对于特定的人，自由选择适合自己的项目，对于特定的项目，自然筛选出最合适的人。</p>
<p>原文还提到一种观点，即传统开发管理能保证艰苦和乏味的工作总能落实。我想这点毫无疑问是错误的。Linux 和 Kubernetes 的文档充足到令人难以置信，反过来只为了领工资才上班的人往往消极对抗撰写文档和测试或调试问题等工作。</p>
<p>开源共同体的目的是制造高质量的软件，在这个共同目标的引领下，不同方面的人才聚拢起来发挥自己的价值，反而是能够找到对传统开发管理认为艰苦和乏味的工作甘之如饴的人才。对于项目维护者来说，认识到这些所谓“无聊”部分的价值，协同参与者完成它们，是项目能够脱颖而出的必要条件。经过二十年来的经验积累，这逐渐成为最有才华的黑客当中的共识。</p>
<p>最后，对于想要实行集市模式的人，这里转述原文提到的“集市模式的必要条件”。</p>
<p>集市从成立伊始，就需要一个可以运行和测试的东西。当开始建设开源共同体的时候，你需要拿出一个像样的承诺。程序此时并不需要特别好，它可以简陋、有错、不完整，文档可以少得可怜。但它至少要做到能运行，且让潜在的合作开发者相信，这个软件在可预见的未来，能演变成一个非常棒的东西。</p>
<p>项目领导人需要能识别出别人的优秀创意，掌握一定水准的设计和编码能力，并且必须具备很好的人际交往和沟通能力。最后一点应该是显而易见的，为了建立一个开源开发共同体，你需要吸引人们，让他们对你做的事感兴趣，让他们乐于看到自己的贡献。一些技巧可能有助于实现这些，但远远不是全部，你的人格特征也很重要。</p>
<h2 id="开源软件的传承"><a href="#开源软件的传承" class="headerlink" title="开源软件的传承"></a>开源软件的传承</h2><p>《开垦心智层》一章讨论开源共同体的发展，以及发展过程中开源软件的所有权及转让的问题。</p>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>原文提到，开源软件的所有权获取有三种形式。</p>
<blockquote>
<p>第一种也是最显然的，就是去创建这个项目，当这个项目在开始时就只有一个维护者而且这个维护者仍然起作用的时候，所有权问题是连提都不该提的。</p>
<p>第二种方式是获取前任对所有权的移交（有点像“接力棒传递”）。这在社区中很容易理解，当项目“所有者”不愿意或者不能在开发和维护中投入必要的时间时，他（她）有义务将项目移交给一个有能力的继任者。</p>
<p>第三种方式是一个项目需要维护但项目所有者已经消失或失去兴趣了。如果你想维护该项目，你的责任是努力找到这个“所有者”，如果找不到，你可以在相关场所（比如 Usenet上专注于该应用领域的新闻组）声明该项目似乎是一个“孤儿”，而你想为之负责。</p>
</blockquote>
<p>我在协助处理 TiDB 里两个合并子项目的工作的时候，实质上就遵循了这里的原则。原来的项目由多名 contributor 参与完成，在当时的 CLA 设置下，要求每位 contributor 都必须和 TiDB 项目签 CLA 才能合并。比起强硬的改变 commit author 绕过 CLA 检查，我建议尝试联系未签署 CLA 的参与者补上。这些参与者被 at 以后很快响应并且解决了问题。</p>
<p>其实参与开源开发的人不是坏人，在项目没有发展出多样性之前，不要擅自以“内部”“外部”这种二元视角界定参与者的属性，也不要假设“外部”是邪恶的。</p>
<h3 id="分化"><a href="#分化" class="headerlink" title="分化"></a>分化</h3><p>原文将分化行为列为开源文化当中的禁忌。分化指的是派生出一个随后不能交换代码的竞争项目，并导致开发者群体的分裂。</p>
<blockquote>
<p>黑客厌恶项目分化的另一个原因是，他们惋惜那些被浪费的重复工作分化后的两个子项目总是有着或多或少平行的演化路线。他们也会注意到分支倾向于分裂合作开发者社区，使得两个子项目的人手都比父项目的人手更少。</p>
</blockquote>
<p>近年来雨后春笋般冒出来的开源项目，在分支和合作问题上起码有两点值得关注。</p>
<p>第一点是对合作的漠视。相当部分项目，号称开源，实则核心成员还是都来自同一个公司团队，规模往往超不出十几人。他们有很强的领地意识，拒绝其他人的参与，或者将其他人的贡献打包进项目整体说成都是该公司的贡献。这样做，使得不同组织的参与者失去动力甚至有种被驱逐出去的意味，实质上只是源码可得的传统项目开发模式。</p>
<p>当然，也有好的案例，且大多来自公司背景不强的项目。例如 <a href="https://github.com/InterestingLab/seatunnel">SeaTunnel</a> 还叫 WaterDrop 的时候，就吸引了不同组织成员的关注和参与，现在又被 Apache 成员关注到，合作进入 Apache 孵化器孵化。</p>
<p>第二点是对分支的痴迷。也就是公司喜欢 fork 出来搞个魔改版本，从不考虑 contributing back 还以为自己占了便宜。且不说这种行为禁锢了原本可以参与共同体的成员，代码分化带来的兼容性问题魔改版本从来不能解决。回过头来把魔改版本抛头换面又煞有介事的“开源”，应该被整个黑客社会所唾弃。</p>
<p>如果说还有一点，那就是那些所谓的“开源技术公司”，如果试图对开源共同体实施某种形式的管控，让商业公司凌驾于志愿者之上，那么这样的项目实际上更容易分化。Elastic 和 <a href="https://github.com/opensearch-project/OpenSearch">OpenSearch</a> 就是一个典型的例子。</p>
<blockquote>
<p>对于相对开放的民主制度而言，它的一个主要优势在于，绝大多数潜在的革命者发现通过在系统中工作比攻击该系统更容易让自己向目标前进。但如果既有政党联合起来“提高门槛”，导致那些较小的不满意团体觉得更难实现自己目标的话，这种优势就很容易被侵蚀破坏。</p>
<p>准入门槛不高的开放过程鼓励参与而非分裂，因为参与者能从中获得成果，而不用付出分裂所需的高昂成本。尽管这种成果可能不像分裂所得成果那样令人印象深刻，但其成本较低，且大多数人都能接受这种折衷。</p>
</blockquote>
<h3 id="冲突与解决"><a href="#冲突与解决" class="headerlink" title="冲突与解决"></a>冲突与解决</h3><p>原文提到，项目当中的冲突与解决主要围绕三个问题展开</p>
<ol>
<li>谁来负责做设计决策？</li>
<li>如何决定哪个贡献者应该被授予荣誉，如何授予？</li>
<li>如何保持项目团队和产品不被分裂为多个分支？</li>
</ol>
<p>第一个问题由上述所有权问题回答。关于分支的问题在上一节已经讨论过了。现在看第二个问题。</p>
<p>无论采用独裁者模型还是委员会模型，黑客的荣誉都跟他创造的价值相关。也就是说，黑客的声誉在礼物文化的大背景下，由他的贡献即赠与开源共同体的礼物的价值所决定。对于独裁者模型来说，独裁者本人需要能够践行这样的规则，否则高水平的参与者就会选择离开。对于委员会模型来说，还有一个额外的问题是委员会自身应该避免冲突。原文质疑委员会模型难以避免冲突</p>
<blockquote>
<p>在这种形式中，我们很难看到内部边界，并因此很难避免冲突，除非委员会内部享有极高水平的和谐与信任。</p>
</blockquote>
<p>但是，今天的软件复杂度越来越不支持独裁者模式。如果独裁者本人已经把部分决策权交给参与者，那么他在运行上就类似于委员会的模式。即使独裁者名义上拥有最终决定权，他与维护某一模块的核心成员仍然需要保持高水平的信任以减少项目当中的摩擦。</p>
<p>结合如今一部分商业公司创建或大规模参与开源项目的背景，如果项目建立的是同侪共同体（community of peers），也就是说成员的角色与个体相关，而不是与他在某个组织的职位相关，在这种情况下依然把委员会的人员增加与企业员工入离职挂钩，这种组织形式就是非常危险的。</p>
<p>具体地说，部分项目照猫画虎地搬来了 Apache 软件基金会式的同侪共同体设计，在决定项目 PMC 成员和 committer 人选时，却变成了公司同事入职，“理应”有 commit 权限，就稀里糊涂的成了什么 committer 或 PMC 成员。一旦离职，则完全不理会项目的发展，甚至出于不愉快恶意捣乱项目的日常事务。这就是没有基于项目的需要和个体对项目的认可和贡献选择委员会成员的弊病。</p>
<p>这是说缺乏多样性的项目中，单一公司的员工需要避嫌吗？当然不是。实际上，成为大力投资该项目的公司的雇员，能够尽可能多的时间投入到项目发展上，公司的员工确实有更大的可能性成为核心成员。但是必须注意的是他的推举应该是客观的，基于项目的需要和个体对项目的认可和贡献来选择。只有这样，才能努力做到委员会内部有极高水平的和谐与信任，这才是这种组织形式下项目长久发展的根基。</p>
<h2 id="开源与商业模式"><a href="#开源与商业模式" class="headerlink" title="开源与商业模式"></a>开源与商业模式</h2><p>《魔法锅》一章的主题是开源与商业模式，着重讨论了反公地模型，软件的使用价值和销售价值，以及当时存在的开源相关的商业模式。</p>
<h3 id="反公地模型"><a href="#反公地模型" class="headerlink" title="反公地模型"></a>反公地模型</h3><p>我曾多次听到有人拿“公地悲剧”来类比开源协同的开发模式，认为后者也会如前者一样失败。</p>
<p>所谓的公地悲剧，指的是假设一个村庄里的所有人都可以不受限制地在一片公共的草地上放牧，如果没有一个共识来抑制过度放牧，出于自身利益的考虑，每个人都会尽可能多的放牧，以期在公地资源耗尽之前从中获取最大价值。</p>
<p>但是，Linux 项目持续三十年，长寿的开源项目比比皆是，这种类比显然是有谬误的。原文从公地悲剧两个必要条件来反驳，一是过度使用，二是供应不足。</p>
<p>公地悲剧的一个必要条件是所有人都放牧会使得草地退化，但是开源软件一旦制造出来，不会因为被过度使用而损失价值。反过来，广泛的使用会提升开源软件带来的价值。这一点很好理解。</p>
<p>公地悲剧的另一个必要条件是没有人会修缮草地，因为公地奖励“搭便车”行为，即你修缮了草地别人就可以无偿分享你的成果，而你的付出别人并不承担，结果是付出比不上被分摊后的收益，于是所有人都不付出。</p>
<p>在开源开发中不会遇到这种情况。这是因为参与者不仅需要解决方案，他们还需要问题被及时解决。因此解决这个问题本身带来的收益就足够偿还成本，而等待别人解决问题则完全无法预期它会在何时被解决。</p>
<p>这部分解释了解决方案必然会被生产出来的问题，但是其创造者为何会无偿发布这个补丁，还需要进一步的讨论。</p>
<p>一方面，很多情况下开发者无法为其确定一个公允的市场价格。另一方面，坐等在补丁上不会有任何收益，反而会带来额外的成本，因为你现在要在上游发布新版本时重复合并这个补丁。由于上游对该补丁的存在并不知晓，这种重复合并甚至有可能是多次重做。毫无疑问，这是非常挫败的。由此看来，只要你需要上游的更新，无偿发布补丁就是最优策略。</p>
<p>但是，这里还有一个问题，如果补丁有足够的差异性，补丁作者为什么不将其闭源以获取其销售价值？对于 GPL 许可的项目来说，项目本身的演化需要与其他各方分享，这不是个问题。但是软件结合的形式有很多，GPL 对软件即服务等方式难以产生约束，还有以其他宽容开源协议如 APL 等许可的项目，这些情形正是当下开源与商业的讨论焦点。</p>
<h3 id="软件的使用价值和销售价值"><a href="#软件的使用价值和销售价值" class="headerlink" title="软件的使用价值和销售价值"></a>软件的使用价值和销售价值</h3><p>在讨论这个焦点之前，我们先看看软件的使用价值和销售价值。</p>
<p>软件的使用价值是它作为一个工具的经济价值，软件的销售价值是它作为一个可买卖商品的价值。大部分软件是作为内部系统被生产出来的，原文认为，这个比例达到九成以上。开发者的薪资实际是出于维护软件的使用价值的目的支付的。</p>
<p>如果你创造的软件主要用于内部系统，而你的薪资也来自于维护它的使用价值，那么通过闭源来保护销售价值是没有意义的，因为你不会将它用于销售。这种情况下，通过开源协同来提高软件本身的开发效率和质量，就是有收益的。</p>
<p>值得注意的是，只要软件的开发在隶属于不同组织的参与者之间共享工作流，采用开源协同的开发方式就没有额外的成本，因为公司为了用上这个软件，总是要付出开发成本的。这个共享工作流的前提条件也是《魔法锅》一文成书时未曾想到的，居然还有人为了形式开源而给同一套代码区分出两套工作流。</p>
<p>原文提到两个常见的反论意见。一个是通过闭源代码保护商业机密。这是无稽之谈，主要是代码设计糟糕。通常来说，你应该将机制开源，编写通用的逻辑，而将商业知识相关的策略单独实现。当然，后者并没有什么开源的必要。</p>
<p>另一个是说闭源能够保护软件安全。这也是谬论。除了上面商业机密泄露的场景，对于纯粹的骇客攻击行为，二进制照样能被破解，开放源码只是多了一种破解的手段。</p>
<p>类似近几天的 Log4Shell 漏洞，难道黑客不读代码就找不到这个问题了吗？如果公司内重新实现日志框架，且不说要达到 log4j2 的水平要付出多大成本，以及生态兼容性的种种问题，难道重新实现的软件就没有其他安全问题吗？</p>
<p>即使不说分析源码的破解手段并不比破解二进制的手段轻松多少，可靠的安全性也依赖于算法及其事先经过彻底的同行评审。这么看来，开源软件反而更容易修复安全问题。Log4Shell 通过同行评审发现后通过必要的 private 邮件列表上报，在上游修复后进行披露，正是这种安全同盟的一般做法。</p>
<h3 id="直接收费的问题"><a href="#直接收费的问题" class="headerlink" title="直接收费的问题"></a>直接收费的问题</h3><p>当然，上面这些讨论仍然没有覆盖当前这波开源浪潮下新出现的商业公司群体，这些公司创造开源软件，并希望基于它们创造的开源软件获利。</p>
<p>原文对直接收费类型的许可证做出了批驳，指出希望在源代码可得的前提下添加某种收费或变相收费的条款，会遭到黑客的反感，从而失去开源共同体的支持。这是因为这类许可证违背了三个开源共同体的共识。</p>
<p>第一个与对等性有关。大多数开源开发者并不反对别人利用他们的礼物获利，只是不能要求有任何人站在一个特权地位上牟利。MongoDB 的 SSPL 在理念上或许沿袭了 GPL 的一些理念，只是它对形成派生作品的描述“形成服务”太过笼统，得不到广泛的支持。但是 MongoDB Inc. 自己并没有按照 SSPL 的要求开放它的整个服务栈的源代码，这种对等性的破坏遭到了黑客的唾弃。实际上，MongoDB 的核心代码几乎只由其公司雇佣的员工开发和评审。</p>
<p>第二个与非有意后果有关。原文提到，对商业使用或销售进行限制并收费的许可证有着令人扫兴的效果。特别是这条规定给某些分发行为笼上了一层法律阴影，而这些活动正是黑客非常愿意鼓励的事。还是 SSPL 的例子，由于“形成服务”太过笼统，几乎所有黑客都倾向于不分发该软件应避免潜在的法律风险。原文认为，黑客很少在这一点上让步。实际上，这也是 OSI 拒绝承认 SSPL 是开源许可证的主要原因。</p>
<p>第三个与保持礼物文化相关，这也是最关键的一个原因。如果许可证在法律上就禁止产生分支，那么黑客们绝对不会认同这样的条款。原文解释到，虽然黑客们不赞成分支，但是分支是“最后一招”。如果维护者不能胜任或者背叛开源文化，可以通过分支来保护礼物的传递。Elastic 与 OpenSearch 就是活生生的例子，以 AWS 的工程师为首的开发者在 Elastic 转向更加封闭的时候基于开源版本分支并独立发展，保持新分支的开源属性。</p>
<h3 id="开源的商业未来"><a href="#开源的商业未来" class="headerlink" title="开源的商业未来"></a>开源的商业未来</h3><p>《魔法锅》随后介绍了当时作者所看到的的若干种基于开源软件的商业模式。这里不需要展开，因为它们都统一在同一个模型下。这个模型就是基础架构和中间件开放，应用和服务收费的模型。</p>
<p>开源基础架构，并利用同行评审的价值，协同跨越组织的参与者创造出类别杀手，做到这点的收益实在太大了。类别杀手指的是即好到没人再想使用其他备选的高质量开源原创项目，例如 Linux 和 Kubernetes 等。</p>
<p>Google 愿意开放 Kubernetes 的源代码，很大一部分原因就是为了联合其他商业公司以及整个开源共同体形成事实标准的垄断，而要做到这一点，开源协同的方式是最高效的。Kubernetes 形成垄断后，越是早期参与项目的组织，越是投入资源大的组织，越能够获得某种程度上的原厂品牌效应，并积累足以应付软件在使用上的种种问题的开发者团队。这些组织通过提供应用级别的定制和维护服务收取报酬。</p>
<p>原文认为应用非常倾向于继续封闭，这种封闭尤其可能出现在自成一体的垂直市场当中，其网络效应也较弱。这其实就是针对特定场景开发的插件或者是针对具体业务接入基础架构的实施。时过境迁，如今的软件复杂度已经不是当年一个全栈工程师从购买服务器到整个网站都能负责开发的年代，雇佣业务实施团队将越来越常见。</p>
<p>这些插件某种意义上也可以算作中间件。实际上，应用和中间件之间的差别会随着时代的发展而变化。原文认为数据库是中间件，但是如今却更被认为是某种基础软件。中间件走向闭源还是开源，取决于软件失效的代价，代价越高，走向开放的市场的压力就越大。</p>
<p>举个例子，AWS 的不少服务是闭源的，但是它们的客户端是开源的。这些客户端就是中间件，如果它们的维护更封闭，那么失效的可能性就会越高。广泛的用户会倾向于使用开源的替代品。一个案例是 AWS S3 的 Rust 客户端 rusoto 和官方后来提供开源版本。</p>
<p>Confluent 依靠提供 Apache Kafka 的服务盈利，整个商业模型包括三个部分。</p>
<p>第一部分是实施，也就是帮助客户业务与 Apache Kafka 对接，乃至于设计整个业务消息平台。这是传统上所说的“外包”工作，由于软件复杂度日益升高，这类工作所需的软件开发技能也越来越丰富，相应的雇佣薪资也就水涨船高。这种模式也被称为订阅，在一个订阅周期内，客户能够获得实施工程师的支持，商业公司在提供工单响应的保障。实施包括支持私有化部署，也包括帮助客户对接云服务。</p>
<p>第二部分是提供基于开源软件的云服务，也就是云上的 Apache Kafka 资源，客户按照使用的节点数或访问量交费，这种模式实际上是商业公司通过出租商业地产盈利。一方面，CPU 和内存等资源本身是成本，用户无论如何也要为这些成本付费。另一方面，商业公司在资源之上提供了消息平台的抽象，屏蔽了部署和运维软件的复杂度，并以此来赚取差价。对于无力自行维护的企业来说，购买云服务就是最优选择。</p>
<p>值得一提的是，这种部署的附加值是工程师水平和硬件成本的函数，云厂商往往能够获取更廉价的硬件成本，因此独立服务提供商最好追求部署和运维本身的开销下降，这种运维和部署的策略是商业机密和盈利的基础。另一方面，可以通过维持云中立，避免供应商锁定等优势，利用云厂商之间的竞争激发用户的优先选择意愿。</p>
<p>第三部分是专有软件，例如 ksqlDB 等。只不过 ksqlDB 的位置更像是接近基础架构的中间件，被 Apache Flink 和 Materialize 等项目挤压了不少生存空间。反观 Apache Pulsar 和 Apache RocketMQ 就没有将类似功能做成专有软件以期销售，避免被其他项目分化用户。</p>
<p>对于哪些软件不适合通过闭源获取商业价值，《魔法锅》一文介绍了应该考虑开放源码的软件，时至今日仍然是正确的</p>
<ol>
<li>可靠性、稳定性、可扩展性非常重要。</li>
<li>除了独立的同行评审，没有其他便捷易行的方法验证设计和实现的正确性。</li>
<li>该软件对客户的业务非常关键，因此客户期望避免供应商锁定。</li>
<li>该类软件受网络效应主导，即你无法实现压倒性的市场控制力。</li>
<li>关键方法属于公共知识。</li>
</ol>
<p>开源与闭源在几乎所有层面上都是并存的，并且呈现出一种动态发展的趋势。</p>
<p>起初，Windows 垄断了操作系统的市场。当 Linux 出现以后，服务端操作系统的份额开始逆转，并且出现 RedHat 等商业公司。原文称为中间件的数据库，起初被 Oracle 主宰，如今它也承受着 PostgreSQL 的冲击，海量提供 PostgreSQL 服务的商业公司也能生存下来。今天，云原生技术和软件即服务的概念改变了软件生产和使用的格局，越来越多的商业公司创造开源软件或参与到其开发当中，目的就是推出下一个类别杀手，并取得之后的软件服务战争的优势。</p>
<p>实际上，最好的商业价值获取方式仍然依赖创造性的垄断，这也是知名商业著作<a href="https://book.douban.com/subject/26297606/">《从 0 到 1》</a>的观点。只不过，软件的复杂度以及开源开发应对这种复杂度在生产力上的显著优势，使得你无法在一个很大的范围内实现垄断。但是你仍然可以找到合适的垂直领域，或者就是为客户做实施——这也许是最垂直的一种方式了。</p>
<p>如今，想要创造局部垄断的一种新方式，是通过开源协同的集市模式创造出一个类别杀手，在此过程中获得某种程度上的原厂品牌效应，并积累足以应付软件在使用上的种种问题的开发者团队。进一步的，将原本的市场格局改变，在不改变固有需求的情况下改变产生商业价值的位置。以操作系统为例，原本商业公司以创造出商业操作系统为竞争优势，Linux 出现后，如何基于 Linux 提供更好的服务，或者看到 RedHat 如今的上云策略，提供海量 Linux 服务器资源的运维和应用的部署服务。</p>
<p>改变不利于自己的商业格局，并在环境有利于自己的时候做好下一次颠覆的准备，才是开源时代的商业未来。我也相信这种形式，能够促使企业家真正成为创新的先锋，而不是被长时间垄断所麻痹，不思进取乃至阻止社会生产力的进步。</p>
]]></content>
      <categories>
        <category>tison</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
        <tag>开源之书</tag>
      </tags>
  </entry>
  <entry>
    <title>大教堂过时了吗</title>
    <url>/flossway/2022/02/18/the-cathedral-recap/</url>
    <content><![CDATA[<p>前些天，我的朋友 tison 写了一篇<a href="/flossway/2022/02/10/the-cathedral-and-the-bazaar/" title="《大教堂与集市》的读后感">《大教堂与集市》的读后感</a>，将当下的开源与当时的观点交叉后全面生动地解读了这本开源运动的经典之作，引起了我再读此书的兴趣。一个好的作者总能回答很多话题，一个卓越的作者却更能引出一些有趣的话题。每读每新，对于作者 Eric S. Raymond (下文简称 ESR) 在书中提出的关于开源的很多有趣话题，比如“大教堂”，我在重读中也有了一些更新的认识。</p>
<span id="more"></span>

<h2 id="大教堂-vs-集市"><a href="#大教堂-vs-集市" class="headerlink" title="大教堂 vs. 集市"></a>大教堂 vs. 集市</h2><p>《大教堂与集市》本是属于 ESR 文集中的一篇论文，而他以该文来命名全书，可见其重要性。事实上《大教堂与集市》作为开源圈经典流传，是基于 ESR 对于开源现象的深刻洞见和独特的观点。同时，作为一个很会讲故事的作者，其中最有特色的就是：他以“大教堂”来寓意软件工程中的集中开发模式，以“集市”来寓意开源的分布式开发模式，然后通过对这两者的比较，推导出了开源的“集市”模式是对传统软件工程的一种颠覆，而“大教堂”所代表的集中式开发则已经是一种相对落伍的模式。</p>
<p>作为一个开源运动的倡导者和布道者，在这点上，他的确是高明的，尤其是他以“大教堂”和“集市”这两个鲜明的比喻来说明传统软件开发和开源模式间的差异，也让很多人一下认识到了开源模式的创新性和独特性。</p>
<p>但，有很多人可能不了解，用“大教堂”作比，并不是由 ESR 最先想到的。大教堂实际是来自软件工程界的传奇经典《人月神话》一书。而且，《人月神话》里的“大教堂”和 ESR 说的“大教堂”，竟然还有些不是那么一回事。</p>
<p>“大教堂”一词最早是出自于《人月神话》的第四章。此书的作者是被业界称为 IBM 360 系统之父弗雷德里克.布鲁克斯博士（下文简称 Brooks)，他以自己在 IBM 公司承担 360 系统的项目开发管理经验以及其他大量软件工程实践，为每个复杂软件项目的管理者给出了自己的真知灼见，并探索了软件设计中概念完整性和一致性的重要性和解决方法等，是任何时代下的软件工程师完全值得的必读之作。</p>
<p>仔细读过《人月神话》的读者一眼可以看出，ESR 在他文章中对于大型软件工程复杂度的阐述显然是受到了 Brooks 的启发和影响。无论从他书里引述的内容，还是写作风格，都无处不在地体现着 Brooks 的影子。一方面他基于 Brooks 的观点提出了开源集市模式的新观点，另一方面也显示了他对老一代软件人的致敬和尊重。甚至于对书封面的选择，ESR 也是选用了俄罗斯画家柳博芙·波波娃的以立体主义和未来主义相结合的著名画作《以图构图》，我猜这是他向老一代软件人致敬的一个彩蛋。要知道 Brooks 在《人月神话》中的写作特色，就是喜欢在每个章节前引用一句他所钟意的名言、名画或名建筑来开场的。</p>
<p>不过，话说回来。再回头看《人月神话》中 Brooks 说的大教堂其实并不是在说软件工程集中式开发管理的复杂，准确一点说，Brooks 其实是在讲软件工程另外一件非常重要的事情：软件设计的概念完整性和设计的一致性。而这点却是无论集中模式还是开源模式，只要涉及软件开发，都无法忽略和忽视的。</p>
<blockquote>
<p>如果我们只是简单地按照 ESR 给我们灌输的观念，去理解大教堂模式的落伍、集市模式的先进，那么无疑是具有片面性和局限性的，这也会阻碍我们更好地去理解开源的本质。 </p>
</blockquote>
<h2 id="大教堂"><a href="#大教堂" class="headerlink" title="大教堂"></a>大教堂</h2><p>首先，Brooks 说的“大教堂”不只是一个比喻，而是有个真实的大教堂故事。他在讲述关于「贵族专制、民主制和系统设计」的第四章中开始就描述了那个他心中真正的大教堂，法国兰斯大教堂 (Cathédrale Notre-Dame de Reims)。</p>
<img src="/flossway/2022/02/18/the-cathedral-recap/cathedral.jpg" class="" title="cathedral">

<p>百度百科里是这样记载的：</p>
<blockquote>
<p>兰斯位于法国东北部香槟-阿登大区的马恩省，是法国的历史文化名城，素有“加冕之城”的美誉。历任法国国王加冕之处的兰斯圣母大教堂（Cathedral Notre-Dame de Reims），在法国的作用相当于英国的威斯敏斯特教堂，巴黎圣母院亦是仿照其建造，是哥特式建筑的杰作之一。1991 年，兰斯的圣母大教堂被联合国教科文组织世界遗产委员会批准作为文化遗产列入《世界遗产名录》。</p>
</blockquote>
<p>兰斯大教堂的神奇之处是在历经八代设计师和建筑的过程中，整座教堂令人出乎意料的在建筑风格上保持了完美的一致性。这个和欧洲其他的一些大教堂形成了鲜明的对比，因为一般的欧洲教堂会由不同时代不同建筑师分不同的时期来建造。由于每个建筑师出于自己的想法和创作意图，后面的建筑师往往为了出于提高和反映自己的风格及体现个人品味，导致教堂在设计和结构风格上存在许多差异。</p>
<img src="/flossway/2022/02/18/the-cathedral-recap/cathedral-difference.png" class="" title="cathedral-difference">

<p>所以，经常会出现哥特式的教堂里依附诺曼底风格的十字架等，在显示了上帝荣耀的同时也彰显了建筑师的独特。虽然它们的独特性也为人称道，但，兰斯教堂却以出奇的概念完整性和设计的一致性让人们赞叹。而这个背后就是参与设计和建造的八代建筑师对于自我的要求和牺牲，以严格地约束自己放弃掉那些可能拥有的独特创意，来最终保持了教堂设计的纯粹性。想来 Brooks 可能是实地去参观过后，被兰斯大教堂的建筑风格所震撼，并由此联想到了软件设计中相关问题。</p>
<p>一个软件的设计开发虽然现在无需经历几代人，但同一个软件任务经常会由不同的软件工程师来完成。Brooks 坚持认为对于软件开发设计中，概念的完整性和设计的连贯性是极其重要的因素。因为它的裨益非常明显，对于开发人员来说是让软件更加容易开发，对于用户来说是更加容易使用。所以，软件应当像兰斯大教堂那样的被开发建造出来。</p>
<p>在对于如何「保证概念完整性和一致性」的解决方法上，Brooks 在当时就大胆而有见地的提出：概念的完整性要求设计必须由「一个人或者非常少数互有默契的人员」来实现。一个成功的软件系统，如果是一个人主导的，那么会很大程度上依赖最初设计者的全局观和天才，后续的建设者则需要放弃部分自己的想法和个性，来延续设计的完整性。</p>
<p>这在《人月神话》20年周年以后的纪念版补充章节中，Brooks 又再次确信和重申了他对于软件设计的概念完整性的几个重要观点的坚持：</p>
<ol>
<li>概念完整性是软件系统设计中最重要的考虑因素。</li>
<li>为了获得概念的完整性，设计必须由一个人或者具有共识的小团队完成。</li>
<li>纪律和规则是有意的，外部的规定实际上是加强而非限制创造性的实现。</li>
<li>体系结构、设计实现、物理实现的许多工作可以并行。</li>
</ol>
<p>所谓的经典就是能够经受住时间的考验。Brooks 关于「软件设计概念完整性和一致性」的观点在20世纪70年代中期被提出，历经技术的变迁和市场的变化，直到纪念《人月神话》四十周年的中文版发行时，依然在被行业的实践证明其有效性。这就是经典。</p>
<p>诚然，传统的集中式软件的开发管理是复杂的，但进一步讲，开源软件的开发管理难道就没有复杂度了吗？一个优秀的开源软件，能从一个或者几个爱好者的级别开始再上升到社区里不同人员参与贡献的程度，实际上也必将经历从不需要管理再到管理复杂的程度。否则，林纳斯也不会在开发了Linux之后，再去专门开发了一个管理 Linux 开发的开源软件Git。而也正由Git开源社区的发展，产生了如Github、GitLab 和中国的 Gitee等开源代码托管和开发协作平台才撑起了开源开发管理的江山。</p>
<img src="/flossway/2022/02/18/the-cathedral-recap/cathedral-vs-bazaar.png" class="" title="cathedral-vs-bazaar">

<p>所以，从软件项目的管理而言，只不过是原来集中式管理变成了开源社区集市模式，治理的难度系数实际上是不会比传统集中式开发小多少的。我们不能因为 ESR 将集市模式比作对于大教堂的替代而想像成两者之间的对立关系。集市模式里大教堂，依然具有存在的必要性和重要性。关于这个观点，<a href="https://mp.weixin.qq.com/s/U28t8OZ4uSItuZtA3faLIw">《大教堂与集市》的中文版</a>译者卫剑钒也在其文<a href="https://mp.weixin.qq.com/s/15kCZNCG1psxyWv0WfOHAw">《开源的7大理念》</a>和<a href="https://mp.weixin.qq.com/s/Witz9483fumBpLoIaBbDlw">《每个人都是一座教堂》</a>都有提及，并客观地指出网络组织下的并发无序开发未必就能够成为一种有效的开发方法。</p>
<blockquote>
<p>这很像是一大群能工巧匠（包括一些建筑公司的团队），不管出自何种利益考虑，为了一个共同的目标，从世界各地自发参加一个大教堂群的设计和建设。Linux 内核就是这样一个大教堂群，每个子系统都是一个大教堂，每个大教堂都有着负责设计和建造的领导人，其下有有着数百名建造高手，他们在共识和规则之下，使用着像 git 和 gcc 以及邮件列表这样的设计、建造和协同工具，利用集体的力量（他们会讨论，也会投票），把这些美轮美奂的大教堂建造出来。Linus 作为最高领导人，不会强制他们，更不会发薪水，一切都是这些高手自发自愿自带干粮，不管是个人还是公司。集市模式和大教堂模式的本质区别只是在于：前者是自发的，也是自治的。</p>
</blockquote>
<p>ESR 在《大教堂与集市》中将“大教堂”比作了一个落后于开源的集市开发模式的代表性词汇，让全世界的程序员知道了大教堂与集市的差别，当然也没有什么错，但却忽略了“大教堂”般的软件工程模式代表着软件开发中本质的一些观点和概念，实际上并不会因为开源的集市模式出现而落伍。恰好相反，如软件概念的完整性和设计的一致性等，“大教堂”模式依然是一个优秀的开源软件所应具备的特性和本质。</p>
<h2 id="拥抱开源，认清内核"><a href="#拥抱开源，认清内核" class="headerlink" title="拥抱开源，认清内核"></a>拥抱开源，认清内核</h2><p>开源是一种新型的软件开发模式，在资源组织和开发协作上的确有其先进性和创新性。但无论是开源软件还是商业专有软件的开发，只要是软件，就有软件本身内在的一些本质特性需要遵循，我们需要明确的是，这些特性未必会因为开源模式而改变！</p>
<p>同样，随着开源热潮和社区的不断兴起，各种开源力量的参与社区贡献和社区治理，我们与其争论开源社区在何种模式下更为合理，不如去专注于那些属于开源真正应有的内在特性，可能更会让开源发扬光大。</p>
]]></content>
      <categories>
        <category>狄安</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>The PostgreSQL Community</title>
    <url>/flossway/2022/02/10/the-postgresql-community/</url>
    <content><![CDATA[<p>PG 社区经过二十五年的发展，早已积累了海量的最佳实践，大多可以从 <a href="https://wiki.postgresql.org/wiki/Development_information">PG 的维基页面</a>上找到。这篇文章不会覆盖所有内容，只做挑选分享，并强烈建议近期如雨后春笋般涌现的开源基础软件公司探索维基页面乃至协同编辑，学习这笔宝贵的财富。</p>
<span id="more"></span>

<h2 id="社区组织"><a href="#社区组织" class="headerlink" title="社区组织"></a>社区组织</h2><p>PG 社区的治理模型简单到我都不太能够称呼它为一个治理模型。</p>
<p>虽然它在全球地域性的协会组织不少，也有行为准则委员会等等组织形式，但是实际对 PG 的开发产生深远影响的是这样两个组织。</p>
<h3 id="Core-Team"><a href="#Core-Team" class="headerlink" title="Core Team"></a>Core Team</h3><p>Core Team 是 PG 社区实质上的指导委员会。它负责代表项目做出决定和协调开发过程当中的冲突，能够做出 PG 社区所有问题的最终决定。</p>
<p>Core Team 一共只有 7 人，来自于 4 家公司，均在 PG 社区贡献了超过十年。最新的 2 名成员在去年底选出，原因是 EDB 收购 2ndQuadrant 后，原本的 5 名 Core Team 成员里有 3 名均来自同一家公司，打破了 Core Team 不该有一家公司有过半数名额的不成文共识。</p>
<p>官方网站的 <a href="https://www.postgresql.org/community/contributors">Contributor Profiles</a> 页面罗列出了 Core Team 成员及其背景和贡献。此外，共有 5 名前 Core Team 成员已经退休。</p>
<p>Core Team 的主要职责包括</p>
<ul>
<li>协调版本发布活动</li>
<li>充当保密沟通信道</li>
<li>发布政策变更公告</li>
<li>管理代码提交权限</li>
<li>处理行为规范问题</li>
<li>无法达成共识时，做出最终决定</li>
</ul>
<p>可以看到，这个角色的职责描述是站在社区利益的角度上来讲的，成为 Core Team 成员并不意味着高人一等，而是有意愿帮助社区协调处理那些难以解决的非开发事务。这是一种贡献而非特权。这启发我们在构建开源社区的时候，定义角色时应该以社区价值为主，而非认为自己在树立特权阶级。社区当中针对某些事务做出最终决定的人，不是社区当中的特权阶级，而是通过信任的传递得到认可的个体。这点在 PG 社区有充分的体现。</p>
<p>PG 社区尤其强调 Core Team 成员应当避免直接决定技术方向和倡议，这些决定最好由公开讨论得出结论，例如在邮件列表上讨论。</p>
<p>新的 Core Team 的成员由当前的 Core Team 任命，过程不公开，仅公示结果。</p>
<p>关于 Core Team 组织形式的补充讨论，可以阅读下面这篇博文。</p>
<p><a href="https://postgresql.fund/blog/is-it-time-to-modernize-postgresql-core/">Is it time to modernize the processes, structure and governance of the PostgreSQL Core Team?</a></p>
<h3 id="Committers"><a href="#Committers" class="headerlink" title="Committers"></a>Committers</h3><p>如同其他开源社区一样，PG 也定义了能够直接向主仓库提交代码的角色。</p>
<p>略有不同的是，其他社区往往会显著的展示 Committers 名单列表，例如</p>
<ul>
<li><a href="https://flink.apache.org/community.html#people">Apache Flink Committers</a></li>
<li><a href="https://curator.apache.org/team.html">Apache Curator Committers</a></li>
<li><a href="https://devguide.python.org/developers/">Python Committers</a></li>
</ul>
<p>PG 社区的 Committers 页面比较朴素，而且由于维基页面缺少索引，比较难找。而且在官方主页上也没有发现任何链接跳转到这个页面。</p>
<p><a href="https://wiki.postgresql.org/wiki/Committers">Committers</a></p>
<p>一共有 28 名成员，对于一个发展了 25 年的社区来说，这个数量算是非常稀少了。</p>
<p>这个名单里仅有 5 名 Core Team 的成员，也就是说有 2 名 Core Team 成员并不在 Committers 队伍里。其中一人致力于社区发展和网站建设，另一人开发了 pgAdmin 工具，开发和维护 PG 社区大量的基础设施，并维护 PG 的安装体验。</p>
<p>同样，这可以看出 PG 社区的 Committers 也是认可和责任胜过特权和等级。后面介绍典型的开发流程的时候，也会看到 PG 社区的 Committers 承担了非常多的责任。关注在其他活动上的 Core Team 成员不想或无力承担 Committers 的职责，于是选择不成为 Committers 的一员。</p>
<p>这是关注在能力和职责而非形式主义的最佳实践。Python 社区也有一部分开发者收到邀请后拒绝成为 Committers 以保持自己业余参与的从容。相比起这股开源之风带起的追名逐利者恨不得给自己安排上更多更响亮的头衔，成熟开源社区的参与风格关注的是项目的成长和自己力所能及的贡献。这其实是 PG 社区少规则，多最佳实践，依靠小团队高度互信运转的基石。</p>
<p>新的 Committers 通常在每年三四月份由 Core Team 选出，并在 PGCon 上宣布，选取过程不公开。淡出社区的 Committers 将会同期被 Core Team 评估后移出 Committers 队伍。</p>
<p>维基页面上描述了选拔 Committers 的一系列宽松共识</p>
<ul>
<li>多年来对 PG 项目做出了重大贡献。</li>
<li>一系列持续的代码贡献。</li>
<li>愿意承担一个或多个领域的维护工作。</li>
<li>主持 Review 进程，帮助其他贡献者提交补丁。</li>
<li>其代码贡献一贯是高质量的，不太需要修订或更正。</li>
<li>深刻理解接受一个补丁的流程和标准。</li>
</ul>
<p>此外，在组织形式上，除了前面提到的全球地域性的协会组织，和行为准则委员会以外，值得一提的是 PG 社区的运作实体是一个叫 <a href="https://www.postgres.ca/">PostgreSQL Community Association of Canada</a> 的非盈利组织。其董事会成员共 6 人。</p>
<ul>
<li>1 人为非 Contributor 的财务官。</li>
<li>3 人为 Core Team 成员。</li>
<li>1 人为前 Core Team 成员。</li>
<li>1 人为茫茫多 PG Contributor 的一员。</li>
</ul>
<p>这个组织和前面两个组织也没有包含关系。</p>
<p>PG 社区真的是有高度的凝聚力和相互信任，以至于它们能够让愿意担责的合适的人出现在对应的位置上，而不用费尽心机地考虑其他背景的贡献者是否可靠，需要怎样保证社区在“控制”之下等等问题。</p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>PG 社区的开发流程可以从下面三个维基页面开始了解。</p>
<ul>
<li><a href="https://wiki.postgresql.org/wiki/So,_you_want_to_be_a_developer%3F">So, you want to be a developer?</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Development_information">Development information</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Developer_FAQ">Developer FAQ</a></li>
</ul>
<p>总的来说，也将开发活动分成 Bug 和 New Features 两种类型，以 CommitFest 的形式迭代。每个流程都非常简单，基本就是邮件列表承载所有讨论，每个人都可以基于技术能力平等地对话，最终达成共识后由 Committers 完成代码提交。</p>
<h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><p>PG 社区是一个非常彻底的志愿者社区，这从他们跟踪处理 Bug 和 New Features 的方式就可以看出来。</p>
<p>PG 社区只提供了报告 Bug 的手段。你可以填写 <a href="http://www.postgresql.org/support/submitbug/">Bug 提交表单</a>或直接给 <a href="mailto:&#112;&#x67;&#115;&#113;&#108;&#45;&#x62;&#x75;&#x67;&#115;&#64;&#112;&#111;&#x73;&#x74;&#103;&#114;&#x65;&#115;&#113;&#x6c;&#x2e;&#111;&#x72;&#103;">&#112;&#x67;&#115;&#113;&#108;&#45;&#x62;&#x75;&#x67;&#115;&#64;&#112;&#111;&#x73;&#x74;&#103;&#114;&#x65;&#115;&#113;&#x6c;&#x2e;&#111;&#x72;&#103;</a> 发邮件，提交表单后也是发到这个邮件列表。愿意关注和修复 Bug 的人会订阅这个邮件列表，参与讨论，并可能在 CommitFest 上提交一个修复。不过 PG 发展了很长时间，用户量巨大，很多报告上来的 Bug 只是理解有误或者使用不当。</p>
<p>PG 社区的 Bug Tracker 只是 <a href="https://www.postgresql.org/list/pgsql-bugs/">pgsql-bugs 的归档</a>，或者干脆就是它没有 Bug Tracker 一说。虽然通过表单报告上来的 Bug 会被分配一个编号，但是直接发给 pgsql-bugs 报告 Bug 的也不在少数。其次，Bug 的修复没有所谓的 Assignee 或者修复以后的关闭，这只是一个邮件列表而已。</p>
<p>与之相对应的，CommitFest 上的 patch 会有专门的一个 Bug Fixes 分类，因此开发者是知道哪些问题被修复了的。Release Manager 也知道，所以会在 Release Note 当中对重大 Bug 的修复有体现。</p>
<p>但是，总的来说，PG 社区的 Bug 修复是随缘的。整个社区以 over communication 的方式运转，没有复杂的流程和状态记录。要想知道你报告的问题现在是什么状态，最好的办法是在邮件列表里把原来的 thread 回复顶起来，PG 社区的参与者是我见到过相当纯粹和极度投入的，如果有人修了，我相信他本人或者另一个人会知道并告诉你。</p>
<p>不过，如果有一个 Bug Tracker 应用，类似于 CommitFest 看板，我想对于 PG 的开发者和用户来说肯定也是一个体验的改进。只不过是社区的贡献者动辄参与十年以上，他们本身对这个流程已经非常熟悉，而作为新人很难提出一个新的工作方式要求现有的贡献者迁移过来。一个疏于维护的 Bug Tracker 没有作用，甚至会产生误导。也许只有某天一个德高望重的 Contributor 决心做这件事情，或者新人完成了应用的开发，制订出一个可行的迁移计划，再说服几个资深的 Contributor 一起推动，这件事才有可能有实质的进展吧。</p>
<p>这其实也是一个成熟社区保护自己的方式。我想这些资深的开发者看过太多昙花一现的创意最终都被时间所淘汰，而现状又没有明显的缺点，这种情况下保持谨慎并关注到演进软件上才是创造核心价值的做法。</p>
<p>Bug fixes 会被尽可能地 backport 到受影响的版本分支上。</p>
<h3 id="Brand-new-features"><a href="#Brand-new-features" class="headerlink" title="Brand new features"></a>Brand new features</h3><p>New Features 在 PG 社区基本等同于前几天的文章 <a href="yatennosyo-0019.md">The ZeroMQ Community</a> 介绍的愿望清单。PG 社区有一个 <a href="https://wiki.postgresql.org/wiki/Todo">TODO</a> 页面松散的记录讨论过的想法创意和愿望清单，但是不保证会有人关注和实现，也不意味着这是合理甚至确定要做的工作。</p>
<p>PG 社区的 New Features 流程仍然是邮件列表讨论，达成共识以后开始进入开发阶段，经由 CommitFest 窗口提交到主仓库中。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Desirability -&gt; Design -&gt; Implement -&gt; Test -&gt; Review -&gt; Commit</span><br></pre></td></tr></table></figure>

<p>上面这个流程就是 PG 社区的最佳实践。首先在邮件列表上讨论 New Features 的价值，大致对价值达成共识后讨论技术设计，再之后进入开发流程，即实现、回归测试、代码评审和最终提交。</p>
<p>New Features 的唯一信源是 <a href="mailto:&#112;&#103;&#115;&#x71;&#x6c;&#x2d;&#x68;&#x61;&#99;&#x6b;&#x65;&#114;&#x73;&#64;&#112;&#x6f;&#115;&#x74;&#x67;&#114;&#101;&#115;&#x71;&#108;&#46;&#111;&#114;&#x67;">&#112;&#103;&#115;&#x71;&#x6c;&#x2d;&#x68;&#x61;&#99;&#x6b;&#x65;&#114;&#x73;&#64;&#112;&#x6f;&#115;&#x74;&#x67;&#114;&#101;&#115;&#x71;&#108;&#46;&#111;&#114;&#x67;</a> 邮件列表上的讨论，同样是走的 over communication 路线。TODO 页面上对于每一个项目，可能会附上对应的讨论链接，也可能没有。获得实际状态，参与讨论或提出方案的方式仍然是发起邮件讨论。</p>
<p>PG 社区强调成功的推动新功能或改进项的合并所需要的做的第一件事就是尽早尽快地在 pgsql-hackers 邮件列表上跟社区成员分享和讨论。这与我们提到过的 <a href="yatennosyo-0016.md">Open Discussion</a> 和 <a href="yatennosyo-0015.md">Public Design</a> 是相通的。</p>
<p>我在和参与开源社区的同学沟通的时候也说，对于一个想做的工作，尽早在社区当中发起讨论，不用等到全部想清楚或者开始做了再说，这样整个生命周期拉长，留给其他社区成员知晓和各种形式的参与的空间大一些。</p>
<p>PG 社区的志愿者属性在这一点上再一次体现。如果是企业主导的开源，由于企业的控制倾向和雇员多年以来做事的习惯，一旦把社区作为和企业对立起来的一个概念，他们在社区当中的参与就会变成自己讨论并私下决定以后“通知”社区。这种方式无法容纳两种不同背景的参与者都这么做，因此要么社区永远只有一个声音，要么主导者主动做出改变，以贡献者而非控制者的形式参与到社区开发当中来。</p>
<p>New Features 只会发布到最新的大版本。PG 社区采用大版本和小版本的版本号形式，小版本就是补丁版本，它的更新不会引入新的功能。</p>
<h3 id="CommitFest"><a href="#CommitFest" class="headerlink" title="CommitFest"></a>CommitFest</h3><p><a href="https://commitfest.postgresql.org/">CommitFest</a> 简称 CF 是 PG 社区所有开发活动的核心流程，甚至说只有这个流程也不过分。</p>
<p>不同于其他社区除发布前停止合并新代码以外随时随地开发和提交，PG 社区以不定期的代码评审活动的形式开放 patch 评审和合并的窗口。目前举办的 CF 活动均为每次一个月，每年四到五次。</p>
<p>除了 CF 以外，发布前 PG 社区也会直接合并发布所需要的代码。但是整个社区的前进节奏大致是跟着 CF 走的，少部分例外由 Committers 判断并在邮件列表上明确地提议和声明提交。</p>
<p>CF 活动有以下几个角色。</p>
<p>CommitFest Manager (CFM) 负责整个 CF 活动各项事务的协调，包括邮件列表通知，为 patch 分配 Reviewer 和跟进所有 patch 的进度等等，非常繁忙。</p>
<p>Reviewer 以 patch 为粒度，任何人都可以参与 review 工作。只需要在 CF 上注册登录以后进入 patch 详情页点击 Become Reviewer 按钮即可。CFM 在开始 CF 前会在 pgsql-rrreviewers 邮件列表上征集本次 CF 的志愿者，RRReviewer 即 Round Robin Reviewer 会在 CF 开始后由 CFM 轮询分配到所有的 patch 上。</p>
<p>每个 patch 都会关联一个邮件，Review 实际也发生在邮件列表上。所有人都可以在 Open Statuses 之间流转状态，CF App 也支持用户订阅状态流转提醒。</p>
<ul>
<li>Needs review 意味着 patch 刚刚提交或经过修订，等待 reviewer 的 review 意见。</li>
<li>Waiting on Author 意味着经过 review 以后有未决的问题或修订意见，需要 patch 作者回复。</li>
<li>Ready for Committer 通常由 reviewer 流转，指在经过 review 后等待 committer 做最后判断。</li>
</ul>
<p>CFM 会关注所有 patch 的进度，一个 patch 在一次 CF 当中的 Closed Status 有以下几种</p>
<ul>
<li>Move to next CF 这是最常见的。当前 CF 窗口内无实质进展或有所推进后由于 reviewer 的时间等问题停滞，推迟到下个 CF 处理。</li>
<li>Returned with feedback 由于 patch 作者未回复而关闭。在当前 CF 周期内，patch 作者可以在邮件列表申诉后重新激活，或者在后续的 CF 活动中重新提交。不同于上一个状态会将 patch 自动顺延到下一个 CF 里，这个状态的 patch 已经离开 CF 的处理循环，需要作者明确地重新提交。</li>
<li>Committed 顺利通过 review 和 committer 的最终判断，合并到主仓库当中。</li>
<li>Withdrawn 主动撤回。</li>
<li>Rejected 明确拒绝。</li>
</ul>
<p>patch 详情页上会有具体的 patch attachment 文件，对于需要 backport 的改动，会有一系列的 patch 分别对应到每个分支上。</p>
<p>考古发现 CF App 在 2014 年才开发出来并投入使用，PG 社区在 2010 年才开始使用 Git 做版本管理。对于开发的最佳实践，在维基上有一系列的页面从各个维度上做了介绍，也有不少贡献者自发撰写的案例。这里只做罗列，不做展开。</p>
<ul>
<li><a href="https://wiki.postgresql.org/wiki/CommitFest_Checklist">CommitFest Checklist</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Submitting_a_Patch">Submitting a Patch</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Regression_test_authoring">Regression test authoring</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Working_with_Git">Working with Git</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Creating_Clean_Patches">Creating Clean Patches</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Reviewing_a_Patch">Reviewing a Patch</a></li>
</ul>
<h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>开发流程另一个值得关注的问题是 PG 如何做版本发布。</p>
<p>PG 的版本计划在 <a href="https://www.postgresql.org/developer/roadmap/">RoadMap 页面</a>上。这个页面不会说 PG 接下来要做什么工作，因为 PG 社区是纯粹由志愿者组成的，没有必须完成的需求一说。这个说法和 ZeroMQ 社区抛弃 RoadMap 的原因如出一辙。这个页面只包含了对大小版本的发布预期。</p>
<p>大版本的发布由 <a href="https://wiki.postgresql.org/wiki/Release_Management_Team">Release Management Team</a> 简称 RMT 完成。RMT 在发布前期在 Committers 当中达成共识选出，一般有 2-3 人。发布的检查内容非常之多，本段最后会列举出对应的阅读材料。总的来说，包括<a href="https://buildfarm.postgresql.org/cgi-bin/show_status.pl">测试</a>和文档以及其他材料准备。</p>
<p>小版本的发布和大版本类似，但是不会有正式的 RMT 来协调各项发布工作。实际上，大版本的 RMT 往往恰好是同时期的小版本发布的实际协调人。还是因为 PG 社区的版本出口最终由一个 7 人组成的 Core Team 审查，28 名 Committers 之间也有极高的互信，所以反而不需要复杂的流程。往往是在邮件列表上协调，走完发布前所需的检查和准备即可发布。</p>
<p>在正式的大小版本之外，还有 Alpha 版本和 Beta 版本。Beta 版本其实是大版本的 Release Candidate 版本，而 Alpha 版本是每个 CommitFest 完成后打出来的一个快照，供前沿黑客使用。</p>
<ul>
<li><a href="https://wiki.postgresql.org/wiki/Release_Management_Team">Release Management Team</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Release_process">Release process</a></li>
<li><a href="https://wiki.postgresql.org/wiki/ReleasePrep">ReleasePrep</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Alpha_release_process">Alpha release process</a></li>
<li><a href="https://www.postgresql.org/support/versioning/">Versioning Policy</a></li>
</ul>
<h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><p>最后，在总结之前介绍一下如何快速开始 hacking PostgreSQL 项目。</p>
<p>开发环境</p>
<ol>
<li>C 开发环境，Git 工具和 Perl 解释器。</li>
<li>克隆代码，<code>git clone http://git.postgresql.org/git/postgresql.git</code> 从主仓库克隆或者 <code>git clone https://github.com/postgres/postgres.git</code> 从 GitHub 镜像克隆。</li>
<li>标准的 <code>./configure &amp;&amp; make</code> 命令，海量的配置选项和 Make 目标。</li>
</ol>
<p>订阅邮件列表，在<a href="https://lists.postgresql.org/">订阅管理页面</a>上注册账号并订阅，相关邮件列表见前文。</p>
<p>Happy hacking!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结地说，PG 社区的特点是，7 人组成的 Core Team 和 28 人组成的 Committers 队伍绝对的受信任。他们完全知道什么时候能做出决定，什么时候需要扩大讨论达成共识。在这个前提下，所有的流程都是松散的启发式的，Committers 和 Core Team 成员有能力做出正确的决定。</p>
<p>这是彻底的精英领导制（meritocracy）。如果用社会资本的思路来分析，PG 社区当中的 Core Team 成员，Committers 和 Major Contributor 都是社会资本的大富翁。整个社区基本是基于对这个技术核心群体的信任在不断演进的。</p>
<p><strong>开源社区的治理模型应当因地制宜。</strong></p>
<p>Kubernetes 社区的目的就是连接生态，其核心架构的开发人员也不多。通过多样的 SIG 连接每一个增长点，把社区玩成了一个游戏。每个参与者愉快地选择一块地，提交 PR 攒指标，成为一个目录乃至一个文件的 OWNERS 成员，最终把社区生态做大。</p>
<p>PG 社区的下游生态大抵也是如此，只是在 PG 数据库内核本身，Core Team 和 Committers 把社区玩成了一个精英俱乐部，一个技术沙龙。持续高质量的贡献，即使不是 Committers 成员，你的 patch 仍然会被采纳和合并。Committers 更像是得到充分信任以后，志愿为贡献者们服务的人。</p>
<p>对于基础软件的开发来说，人月神话的警示是最明显的。Committers 人数更多并不代表着质量更高。相反，盲目的扩张核心成员可能导致社区行为规范割裂甚至荡然无存，技术审查漏洞百出甚至重复实现相同功能或不同逻辑之间打架。</p>
<p>当然，因地制宜的潜台词是要与时俱进，因为社区不会一直都在同一个地方。PG 社区在漫长的演进过程中逐渐采纳了 Git 作为版本管理系统，CF App 取代了维基页面来协同开发流程，去年由于收购案引起的 Core Team diversity 受到挑战也使得社区当中出现了考虑治理模型的声音。诸如此类。</p>
<p>对 PG 社区的实践的调研给我最大的启示是，高质量的开源软件社区需要强有力的高内聚的技术核心。能够相信这个技术核心做出的判断，并且在流程上减轻他们的负担，让信息自由的流动触达到对应的人，减少信息传递当中的噪声。</p>
]]></content>
      <categories>
        <category>tison</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
        <tag>开源共同体</tag>
        <tag>开源案例库</tag>
      </tags>
  </entry>
  <entry>
    <title>共同创造价值</title>
    <url>/flossway/2022/02/10/value-creation/</url>
    <content><![CDATA[<p>如何吸引开源开发人员参与项目？如何让他们留下来，成为项目共同体的一部分？这是两个做开源运营必须回答的问题。</p>
<p>我对这两个问题的回答，简而言之是和开源参与者共同创造价值，使得开源项目和开源共同体能够回答潜在参与者的两个事关去留的灵魂提问。</p>
<ol>
<li>我能为你做什么？</li>
<li>我应该怎么做到？</li>
</ol>
<p>从共同创造价值的角度出发，通过开源运营回答参与者可以做什么的问题，只有可做的事情是令人兴奋的价值创造，才有可能触发潜在的参与者的兴趣。进一步，只有潜在的参与者能够在文档材料与其他成员的帮助下共同完成价值创造，这样的正向激励才能让参与者留下来，成为项目共同体的一部分。</p>
<span id="more"></span>

<p>本文内容部分整理自我在开源社举办的 COSCon’21 活动上的主题分享<a href="https://www.bilibili.com/video/BV1Tg411K7KS/">《Why Contributors Stay and Grow》</a>的第二部分。</p>
<h2 id="我能为你做什么？"><a href="#我能为你做什么？" class="headerlink" title="我能为你做什么？"></a>我能为你做什么？</h2><p>考虑一个开源开发人员接触项目的典型旅程。他首先要知道这个项目的定位是什么，以决定是否进一步了解它。</p>
<p>如果项目的定位看起来很有趣，或者像是正在解决他希望解决的问题，那么进一步激发他参与贡献的诱因，就是他发现可以为这个项目做点什么。</p>
<p>如果这个项目复杂到无从下手，没有任何引导回答“我能为你做什么”这个问题的入口，那么大部分潜在的参与者都会选择直接放弃理解，也就无法参与。如果这个项目简单到不需要添加什么功能，例如 <a href="https://github.com/antirez/linenoise">LineNoise</a> 和 <a href="https://github.com/pacman82/atoi-rs">atoi-rs</a> 等等，或者稳定到没遇到任何迫切的新需求，例如 ZooKeeper 等等，那么大家已经用得特别开心，也就少有参与贡献的动机了。当然，后者或许是件好事。</p>
<p>我们考虑一个蓬勃发展当中的项目，它足够复杂以不断产生新需求，它又很有活力以致力于把问题解决得足够好。在这样的项目里，潜在的参与者通常能够为项目做什么呢？从这个角度出发，也就能够知道哪些是可能的动机触发点，以拓展共同创造价值的故事。</p>
<h3 id="代码之内的参与"><a href="#代码之内的参与" class="headerlink" title="代码之内的参与"></a>代码之内的参与</h3><p>开源项目最终生产的是开源软件，很容易想到围绕软件代码参与贡献。典型的代码贡献可以分成这四类。</p>
<ul>
<li>评审代码</li>
<li>修复缺陷</li>
<li>改进实现</li>
<li>增加功能</li>
</ul>
<p><strong>首先要讲的是评审代码。</strong></p>
<p>这是一种经常被忽略的参与动机。因为相当部分开源共同体，总是考核并引导参与者自己写代码和提交补丁，只把写代码当成贡献，而将评审代码视作一种不得已而为之的成本，甚至当做是 committer 和 maintainer 的特权。</p>
<p>这当然都是不对的。</p>
<p>实际上，code review 是开源开发人员之间交流技术和建立信任的主要手段。大部分软件的生产过程中，解决问题的办法往往不止一种。每个项目会在众多可能性当中选择自己认可的技术实践，形成自己的调性。通过代码和文档，以及生产代码和文档的过程，这种调性以共识的形式从核心成员同步到每一个参与者的认知当中。这里所说的生产代码和文档的过程，code review 就是其中重要的一环。</p>
<p>对于潜在的参与者来说，参与代码评审并提出问题，门槛较之提交补丁整体要低一些。当然，评审代码并留下意见建议，很多时候要求 reviewer 对软件的理解比补丁作者本身要更高。然而，这里所说的参与代码评审并不局限于针对补丁的实现提出形如补丁的补丁的意见建议，而是强调围绕补丁代码观察和讨论本身。</p>
<p>例如，PostgreSQL 共同体的 <a href="https://commitfest.postgresql.org/">CommitFest</a> 就允许任何参与者以 reviewer 的角色评审待合并的补丁。合并代码的动作自然只能由经验丰富的 committer 来执行，但是任何对这个补丁感兴趣的人，都可以参与评审。你可以针对实现提出问题，可以针对文档提出建议，可以本地测试补丁并回报结果，可以就自己不理解的地方，遵守<a href="http://www.catb.org/~esr/faqs/smart-questions.html">提问的礼仪</a>提出问题。当然，如果某个补丁解决了你的问题，或者实现得非常精彩，不要吝啬感谢、赞扬和鼓励。</p>
<p>TiDB 开发者指南当中有专门的一个章节，告诉潜在的参与者他可以通过<a href="https://pingcap.github.io/tidb-dev-guide/contribute-to-tidb/review-a-pr.html">评审代码</a>的方式为开源共同体做出贡献。其中关于撰写 review comments 的建议值得在这里分享。</p>
<ul>
<li><strong>Be respectful to pull request authors and other reviewers.</strong> Code review is a part of your community activities. You should follow the community requirements.</li>
<li><strong>Asking questions instead of making statements.</strong> The wording of the review comments is very important. To provide review comments that are constructive rather than critical, you can try asking questions rather than making statements.</li>
<li><strong>Offer sincere praise.</strong> Good reviewers focus not only on what is wrong with the code but also on good practices in the code. As a reviewer, you are recommended to offer your encouragement and appreciation to the authors for their good practices in the code. In terms of mentoring, telling the authors what they did is right is even more valuable than telling them what they did is wrong.</li>
<li><strong>Provide additional details and context of your review process.</strong> Instead of simply “approving” the pull request. If your test the pull request, report the result and your test environment details. If you request changes, try to suggest how.</li>
</ul>
<p>另外，代码评审并不局限于补丁合并之前，也不是必须发表评论。</p>
<p>如果一个已合并的补丁激起了你的好奇心，或者你发现了其中存在的问题，完全可以 review after commit 即合并后评审。这对于高速发展的项目来说尤其重要，因为它们往往会在较短的时间窗口内合并补丁，乃至直接向主分支推送代码。代码评审不是形式主义，不像某些极力推行某种流程的人所宣称的必须在合并前收集到两个赞同才能合并，务实的评审和合并策略应该是持续发生、交错进行的。</p>
<p>不是必须发表评论，意思是所有的参与者在提交代码之前，都应该了解他所要参与的这个开源共同体的惯例，也就是常说的“入乡随俗”。这个过程一般也是通过浏览现有补丁来完成的，其实也算是评审代码的一类。我在撰写提交信息和实际提交补丁之前，往往都会先观察共同体当中的其他人是怎么做的，避免不必要的摩擦，提高协同的效率。如果当前流程有明显的缺陷，也是一个潜在的参与点。</p>
<p><strong>修复缺陷、改进实现和增加功能，这三种都是代码贡献。</strong></p>
<p>理想情况下，潜在的参与者具备代码贡献所需的技术背景，在使用软件或阅读代码的过程中，自己发现可能的改进项，仿照现有的 pull request 风格提交补丁。</p>
<p>这种情况也不算少见。常见的案例是参与者掌握了一项新技能，例如一种新的代码风格或设计模式，一种项目管理或持续集成实践，或者一种具有一定普遍性的功能，从而把已经完成的工作，带到其他缺乏这个改进项的项目当中。具体的例子，比如我在看到我的工作里引用的 atoi-rs 项目，没有按照 Rust 项目的惯例配置支持的 Rust 版本，同时功能开发趋于稳定但却没有发布 1.0 版本导致我不是特别敢用，就通过 issue 和 pull request 的方式直接把我掌握的技能复刻到该项目当中。</p>
<ul>
<li><a href="https://github.com/pacman82/atoi-rs/issues/14">Remaining works for 1.0 release</a></li>
<li><a href="https://github.com/pacman82/atoi-rs/pull/17">improve MSRV settings</a></li>
</ul>
<p>上面的例子里有一点值得强调，就是当潜在的参与者不确定能够为开源项目做什么的时候，可以直接询问。当然，这种询问应该是有的放矢的，询问之前应该对项目做基本的了解，而不是居高临下的要求维护者准备好甚至生造出待完成的工作并交给自己。</p>
<p>反过来，从项目维护者的角度出发，回答代码贡献层面潜在的参与者可以做什么的问题，能够采取的方式包括以下几种。</p>
<p>第一种，也是 GitHub 原生支持和倡导的方式，就是为 issue 标注 good first issue 或 help wanted 标签。我在<a href="https://mp.weixin.qq.com/s/OW4AgqsQNBGT2scjGMR-pA">夜天之书 #7</a> 一文里讨论过这两种标签的使用方式。绝大部分 GitHub 的用户的心智模型能够适配这两个标签，并且首先会尝试寻找 good first issue 或 help wanted 标签标注的 issue 作为参与的切入点。</p>
<p>第二种，以 tracking issue 的形式组织起待办事项。通过将零散的 issue 和 pull request 按照主题和模块组织起来，以类似于重构和组织代码的形式管理 issue 和 pull request 来降低潜在参与者的理解成本。</p>
<p>这种做法全面推行，就会在顶层形成一个项目的路线图。例如 <a href="https://flink.apache.org/roadmap.html">Flink 的路线图</a>就把项目的模块分得比较清楚。每个模块现在是稳定状态，快速开发状态，还是原型状态也会标注出来。进一步的，列出每个模块当前正在进行的 Flink Improvement Proposal 和背景，开发人员就可以从这个入口了解相关工作，再从 proposal 关联的 tracking issue 参与到开发工作里面来。当然，这个过程里还有许多可以做代码之外的参与的切入点，这里不做展开。</p>
<p>路线图的更新频率比较慢，日常开发工作里接触得多的是 tracking issue 和对应的改进提案。成熟项目基本都会有一个完整的提案流程，从“我能为项目做什么”的角度出发，这个流程里包含的信息应该可以教会潜在的参与者分辨不同阶段的提案，并且理解当前阶段提案发起人需要得到哪些帮助。另一方面，关于 tracking 的组织，我做过一个视频<a href="https://www.bilibili.com/video/BV1AV411W7WD/">《如何在开源社区做项目管理？》</a>具体讨论的实践手法。</p>
<p>这些手段的最终目的是一致的。因为开发活动过于琐碎，单个开发活动的价值很难吸引潜在的参与者付出时间和注意力自己补全所需的细节。这种情况下，作为项目维护者和开发活动的发起人，应该尽可能地从多个层面以人能理解的方式把这些具体的开发活动归纳总结，以提供不同详略程度的内容呈现。</p>
<p>如同前文提到的，这个过程类似于重构和组织代码。你不能指望开发人员一上来就盯着每一行代码看，这样低效率的理解项目的定位、设计和发展方向。同样，你也不能指望潜在的参与者从大量琐碎的开发活动里归纳出项目共同体正在做什么，接下来要干嘛。只有把开源项目的开发活动模块化和主题化，才有可能把理解和参与的门槛降低到当前时代下潜在参与者所愿意付出的精力的范围之内。</p>
<p>这其实不止是开源项目的问题，而是一个普遍的项目管理的问题。把潜在的参与者换成项目团队的萌新成员，推理过程和结论一样成立。项目维护者采取这样的做法，也不是全然无私奉献，而主要是控制软件工程由于复杂度增加带来的熵。这对于项目本身的健康快速发展也是有利的。</p>
<h3 id="代码之外的参与"><a href="#代码之外的参与" class="headerlink" title="代码之外的参与"></a>代码之外的参与</h3><p>开源共同体虽然是围绕开源软件形成的，但是可能的参与形式远不止于代码贡献。<a href="https://www.apache.org/theapacheway/index.html">The Apache Way</a> 经常被人引用的一点就是“共同体高于代码”。</p>
<blockquote>
<p><strong>Community Over Code:</strong> the maxim “Community Over Code” is frequently reinforced throughout the Apache community, as the ASF asserts that a healthy community is a higher priority than good code. Strong communities can always rectify problems with their code, whereas an unhealthy community will likely struggle to maintain a codebase in a sustainable manner.</p>
</blockquote>
<p>其实，这里的 community 是包括 code 的，两者并非互斥关系，只是强调决策的基点是共同体的利益，而不只是关注代码。不过，我们首先看到开源共同体当中代码之外的参与形式。</p>
<p><strong>第一类是使用。</strong></p>
<p>开发软件的最终目的是投入使用，因此，使用软件并报告反馈，本身就是参与贡献。我见过不少数据库开发人员，并不了解数据分析师和业务开发人员等具体用户到底是怎么使用数据库的，生产环境里最常见的用法，最常被使用的 SQL 特性，沉浸在内核开发当中的工程师未必能够非常准确的把握。通过测试软件在生产环境下的表现，使用真实业务负载验证软件最终交付的价值，对开源软件的打磨价值都是不可忽视的。</p>
<p>TiDB 共同体非常重视用户使用。<a href="https://zhuanlan.zhihu.com/p/272761218">“我们已经用起来了”</a>，是他们最喜欢听到的话。TiDB 的 <a href="https://asktug.com/t/topic/542887">AskTUG</a> 论坛上每天都有海量的问题。这些问题大部分都比较初级，但是初级问题反复出现，意味着开源项目的文档建设和知识库建设不够充分，缺少一个快速上手的文档和常见问题的列表（FAQ）。除去这部分问题，进阶的问题能够描述清楚一个具体的使用场景和遇到的障碍。这类问题往往可以使用某种技巧绕过，这些技巧集合起来，就是使用软件的最佳实践。</p>
<p>前面提过，开发软件的最终目的是投入使用，而软件最终投入生产是一个复杂的过程，任何一个环节无法满足需求，没有绕过方案，都有可能导致用户放弃使用。而任何软件刚刚发布的时候，都是存在这样那样的问题的。通过使用软件并报告反馈，其实就是常说的“踩坑”过程，逐步把软件使用的“坑”给填平，开源软件触达更多用户也就成为可能。为什么 Java 生态比 C# 生态好这么多？为什么 Python 生态比 Elixir 生态好这么多？相当一部分原因就是在漫长的用户使用过程当中，许多未来用户可能遇到的问题，都被先行者给解决了。</p>
<p>对于具备技术能力的开发者来说，使用上游软件并发现问题，还有可能是深入参与的契机。例如我在改进 Apache Flink 的高可用模块的时候，深入理解了 Apache ZooKeeper 和 Apache Curator 的设计实现，并以此为契机为两个项目做出贡献，并成为 Apache Curator PMC 的一员。</p>
<p>另一方面，上面提到的旅程当中，除了使用者以外，还有一个角色就是答疑者。只有少部分提出问题的人，能够自己解决问题。大部分提出问题的人，都需要有另一个经验更丰富的共同体成员协助解决问题。</p>
<p>AskTUG 论坛有版主机制，赋予积极答疑并愿意承担一定协调责任的成员版主的头衔和权限。通过开放合作，AskTUG 论坛聚集起近十位版主，为解答 TiDB 系列产品用户遇到的问题发挥了中流砥柱的作用。可以从<a href="https://asktug.com/t/topic/183426">《TiDB 社区版主，一群平凡又伟大的 TiDBer》</a>一文当中窥见一二。</p>
<p>Apache 基金会治下的项目共同体，往往也强调承担答疑职责的重要性和共同体对这种行为的认可。例如，Apache Flink 项目对 committer 候选人的第一个期待，就是能够积极回答用户问题</p>
<blockquote>
<p>Community contributions include helping to answer user questions on the mailing list, …</p>
</blockquote>
<p><strong>第二类是发布。</strong></p>
<p>发布一个软件并非易事，<a href="https://perlbrew.pl/Perlbrew-%E4%B8%AD%E6%96%87%E7%B0%A1%E4%BB%8B.html">《Perlbrew 中文简介》</a>一文中介绍了 Perl 5.8.8 到 5.10.0 版本之间的发布工作燃尽了两位顶级黑客的精力和热情的故事。</p>
<p>这个故事以发布流程的改进为结局，后来的 Perl 版本发布短到一个月内就可完成。不过，发布这一活动作为开源软件生命周期的重要一环这个事实，却从来没有改变过。PostgreSQL 共同体每次发布都会有一个两到三人组成的临时发布团队，并且整个发布流程都被记录在 Wiki 文档里。我在<a href="https://mp.weixin.qq.com/s/M43TJVxb6CykPI8MiFS55w">夜天之书 #20 The PostgreSQL Community</a> 里有一整段详细讨论。Engula 项目第一份开发者文档，就是<a href="https://github.com/engula/engula/blob/bbbfd9bbaa60bdd7b46adf04c9af658da9e67057/docs/dev/release-guide.md">发布指南</a>。<a href="https://community.apache.org/apache-way/apache-project-maturity-model.html">Apache 项目成熟度模型</a>里，也对发布的质量详细区分了五个等级。</p>
<p>软件的发布是持续交付或叫持续部署的一环，涉及的专业知识不比开发软件核心功能少。一个项目有可靠的持续交付，下游用户才能基于它构建起繁荣的生态。</p>
<p>举个例子，我在分析 TiDB 软件工程上的问题的时候，就提出过发布过程和产物不够清晰，版本支持策略未定义等问题。现在的 TiDB 不像 Apache 项目有明确的文件服务器和稳定获取发布产物的地址，而是依靠工具来完成部署。耦合发布和部署不是一个好选择，尤其是在上一个<a href="https://github.com/pingcap/tidb-ansible">部署工具生命不过三年</a>，<a href="https://github.com/pingcap/tiup">新工具生命不过两年的</a>的情况下。<a href="https://mp.weixin.qq.com/s/DXdDvyo9l3r7Uu3HO5cQ9w">Bytebase 支持 TiDB 的旅程</a>当中，虽然不乏对部署工具的赞许，但也指出了新工具只支持新版本的缺点。由于耦合，部署工具不支持，发布产物也就难以获取。另外，文中也直接明了地提出了版本策略不清晰带给下游的问题。</p>
<p>随着开源吞噬软件，融合不同组件的解决方案在交付时如何进行合规审计和安全审计也是一个日渐复杂的问题，这些问题都归属于发布这一开发活动当中。如果你是一个掌握软件持续交付经验的人才，从这个角度切入参与开源共同体将是非常犀利的，这也是当前不少开源项目求之不得的人才。</p>
<p><strong>第三类是内容。</strong></p>
<p>围绕开源软件开展内容创作，是几何级数乃至指数级数壮大开源共同体的秘诀。内容创作可以大体可以分为四个类型，即文档、博客、演讲和演示。</p>
<p>文档是最贴近开源软件的内容创作。实际上，不少开源软件把用户文档作为版本交付的一部分。<a href="https://docs.pingcap.com/tidb/stable">TiDB 的用户文档</a>经常受到赞扬，<a href="https://www.kubernetes.dev/community/">Kubernetes 的共同体文档</a>也被其他开源共同体用作治理和运营的参考材料。</p>
<p>类似的例子数不胜数。一位经验丰富的技术写作者在交流过程当中曾经提到，好的内容创作能够简明扼要的抓住潜在参与者的注意力，在这个信息爆炸的社会当中为开源共同体赢得劳动时间的投入。</p>
<p>好的用户文档获取用户的注意力，提高软件普及程度，扩大开源共同体生存的基本面。好的开发者文档获取参与者的注意力，减少参与贡献过程当中的摩擦损耗，提高协作效率。好的愿景和价值观，能够聚拢起志同道合的参与者长期为项目发展持续做出贡献。</p>
<p>高质量的文档，必定基于对核心开源软件的理解，对受众的共情，以及文字写作的功底。Apache Pulsar 的 PMC 成员 <a href="https://lists.apache.org/thread/22zl46xlthzk8lmmcdm2r3vhcn4nn5qf">Jennifer Huang</a> 正是出于为 Pulsar 共同体创作技术文档等内容而收获认同的。</p>
<p>博客可以认为是文档的延伸。它是不那么正式的，具备个人风格的内容。同样，许多知名的开源项目，在文档之外都会维护一个博客列表。开源共同体当中也会传阅列表之外的优质博客。例如，我一下子就能想起来 Flink 相关的两篇让我获益匪浅的博客。</p>
<ul>
<li><a href="https://wuchong.me/blog/2020/02/25/demo-building-real-time-application-with-flink-sql/">基于 Flink SQL 构建流式应用</a></li>
<li><a href="http://www.whitewood.me/2020/06/08/Flink-1-11-Unaligned-Checkpoint-%E8%A7%A3%E6%9E%90/">Flink 1.11 Unaligned Checkpoint 解析</a></li>
</ul>
<p>类似的例子也比比皆是，我在撰写 This Week in TiDB 期间也多次引用了共同体成员发布的高质量博客。博客的下一步就是书籍，例如 Eric S. Raymond 为 Linux 共同体做宣传的<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>。很明显，这些内容的传播效率较之软件代码、改进提案和用户文档本身，具有更好的传播效果。这一点还体现在中文社群当中多有对知名开源项目提案的解读上。</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/354979657">JEP 402: 统一基本值与对象</a></li>
<li><a href="https://mp.weixin.qq.com/s/Vr9IQIGvevimeo_A2_I3KQ">2022 年异步 Rust 的改进计划</a></li>
</ul>
<p>演讲的传播效果较之博客又要更进一步，因为它不需要受众阅读并理解文字的含义，而是通过视听体验直接获得感觉。Linus 的经典演讲相当之多，他在这些演讲当中表达的观点为 Linux 项目聚拢起志同道合的核心成员发挥了重要作用。</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=JZ017D_JOPY">Linus Torvalds on his insults: respect should be earned.</a></li>
<li><a href="https://www.youtube.com/watch?v=IVpOyKCNZYw">Linus Torvalds - Nvidia F_ck You!</a></li>
</ul>
<p>Flink Forward 大会，KubeCon 大会，COSCon 中国开源年会，越来越多开源共同体举办的峰会集中输出开源文化和开源软件的价值，以影响整个软件行业对开源软件的认识和使用。作为开源世界的一员，无论是参与演讲还是运营支持，以至于发起峰会，都是对开源共同体壮大的重要贡献。</p>
<ul>
<li><a href="https://www.flink-forward.org/">Flink Forward</a></li>
<li><a href="https://www.youtube.com/watch?v=BbDUZFGJoHw">Panel Discussion: How to Attract Developers to Join Your Community</a></li>
<li><a href="https://space.bilibili.com/525037536/channel/collectiondetail?sid=63363">COSCon’21 第六届中国开源年会</a></li>
</ul>
<p>最后要讲的是演示。演示可以融入到上面提到的三种方式当中。例如，文档可以加入快速开始的演示项目，上面提到的《基于 Flink SQL 构建流式应用》博文本身就是一个示例应用的讲解，演讲当中也经常插入演示环节增强表现效果。</p>
<p>单独谈论演示的原因，自然是因为它非常重要。在信息爆炸、注意力稀缺的今天，短视频以其能够快速抓住眼球，从而大量占用用户时间成为应用新贵。演示起到的就是一个类似的效果。例如，<a href="https://en.wikipedia.org/wiki/Black_Perl">Perl 的代码诗</a>在相当一段时间内吸引了众多开发者的兴趣和尝试。例如，<a href="https://zhuanlan.zhihu.com/p/379477275">TiDB 的热力图活动</a>既强调了 TiDB 重视可观测性的调性，又足够有趣以吸引潜在用户试用。例如，<a href="https://www.bilibili.com/video/BV183411E7Ua">太极图形的太极开物宣传视频</a>就将它在计算机图形学领域的先进性和应用价值生动的传达给每一个观众，相当惊艳。</p>
<p>在软件开发越来越趋于复杂的今天，能够通过演示为开源共同体赢得更多的关注乃至劳动时间的投入，就是为开源共同体做出的重大贡献。</p>
<h3 id="再谈代码贡献"><a href="#再谈代码贡献" class="headerlink" title="再谈代码贡献"></a>再谈代码贡献</h3><p>如同我在《Why Contributors Stay and Grow》演讲里最后要回过来强调的一样，虽然比起代码贡献，代码之外的参与种类繁多，并且能够达到的传播效果远超代码贡献本身，但是开源共同体的价值，始终是建立在优秀的开源软件之上的，而开源软件，说到底还是代码支撑起核心功能，编译产物是交付物的主要内容。</p>
<p>我们在强调 Community Over Code 的时候，需要避免过犹不及。Community Over Code 不应该忽略核心成员的能力和影响力，开源共同体的价值核心，还是依靠这些核心成员尤其是写出最初的代码，一开始规范软件开发流程的人来定义的。用户使用和反馈也好，内容创作也好，前提是有一个好用的软件。虽然上游软件应该适应下游需求来创造，但是最终形成的开源共同体，还是上游定义的软件及围绕开发软件的共同体的价值观推向下游的。</p>
<p>这一点很好理解。创作 GNU 系列项目的人，通过软件及共同体传播自由软件的理念。Linux 选择了 GPLv2 协议，进而影响了整个 Linux 发行版的生态的调性。试图抛开软件，抛开具体的核心成员，定义一套任何人都可以采用的方案建设成功的开源共同体，是不切实际的。这就像是没有一个确保成功的创业法则一样。</p>
<p>只有深入参与到共同体的发展历程当中，通过长时间的投入赢得声誉，建立影响力，并且对软件的定位和共同体的价值取向有相当的理解，对参与共同体发展的核心成员乃至所有成员都有良好的联系，才能够结合具体的情况从共同体层面为现在该干什么，下一步该怎么走做出正确决策。</p>
<h2 id="我应该怎么做到？"><a href="#我应该怎么做到？" class="headerlink" title="我应该怎么做到？"></a>我应该怎么做到？</h2><p>前面讨论“我能为你做什么”的问题的时候，针对每一种可能的参与手段，其实已经或多或少回答了“应该怎么做”这个问题。因此，本段不再对前文已经提过的内容做复述，而是从回答“我应该怎么做到”这个角度出发，给出一个结构化的答案。</p>
<p>我认为，要想解决潜在的参与者提出的“我应该怎么做到”参与贡献的问题，项目维护者应该从这三个方面入手。</p>
<ul>
<li>内容</li>
<li>论坛</li>
<li>聊天室</li>
</ul>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>前文已经花了不少篇幅讨论为开源共同体创造内容是重要的贡献。这种贡献一部分就体现在能够回答“我应该怎么做到”这个问题上。</p>
<p>不同于论坛和聊天室的形式，内容是一种较为单向的信息传递方式，即潜在的参与者单方面的接收内容（主要是文档）传递的信息。因此，内容应该着重考虑受众的体验，解答最为常见，答案最为明确甚至固定的问题。例如，共同体的角色划分和治理体系，共同体认可的价值观，报告缺陷、评审代码、提交补丁等活动的一般性流程等等。</p>
<p>以 TiDB 开发者指南为例，其第二章 Contribute to TiDB 就是我和张翔专门为了回答“我应该怎么做到”撰写的文档，从它的结构就可以看出我们是如何系统性地回答这些问题的。</p>
<ul>
<li>Community Guideline</li>
<li>Report an Issue</li>
<li>Issue Triage</li>
<li>Contribute Code</li>
<li>Cherry-pick a Pull Request</li>
<li>Review a Pull Request</li>
<li>Make a Proposal</li>
<li>Code Style and Quality Guide</li>
<li>Write Document</li>
<li>Committer Guide</li>
<li>Miscellaneous Topics</li>
</ul>
<p>其他成熟的开源共同体也有类似的材料。</p>
<ul>
<li><a href="https://devguide.python.org/">Python Developer’s Guide</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/">rustc-dev-guide</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Development_information">Development information</a></li>
<li><a href="https://flink.apache.org/contributing/how-to-contribute.html">Apache Flink: How To Contribute</a></li>
</ul>
<p>更不用说称得上“卷帙浩繁”的 Apache 基金会的文档和 Kubernetes 共同体的文档。</p>
<p>这些文档，加上共同体当中热衷于布道和培养新人的成员在博客和演讲上的内容分享，是潜在参与者了解如何具体参与一次贡献的直接材料。你正在阅读的这篇文章本身，也作为内容有着回答应该怎么参与贡献的作用。</p>
<h3 id="论坛-聊天室"><a href="#论坛-聊天室" class="headerlink" title="论坛 + 聊天室"></a>论坛 + 聊天室</h3><p>上面提到，文档和博客等形式，潜在的参与者作为被动接收方往往只能单向地获取信息。然而，真实世界当中参与开源共同体的活动，往往每个人都会遇到对于自己独一无二的问题。这些问题不够普遍，所以并不能在解决一般性问题的文档上找到答案。为了解决参与贡献旅程上“最后一公里”的问题，我们需要一个对等的沟通工具。</p>
<p>我在<a href="https://mp.weixin.qq.com/s/gOcQpXtUPqr1Ti7Hkyr_RQ">夜天之书 #16 Open Discussion</a> 一文里介绍过 TiDB 共同体解决这个问题的心路历程，这个经验应用到建设 Engula 开源共同体当中，就是 <a href="https://docs.github.com/en/discussions">GitHub Discussions</a> + <a href="https://zulip.com/">Zulip</a> 即论坛 + 聊天室的模式。</p>
<p>其中论坛是唯一信源，也就是说，类似于 Apache 共同体强调的一切都发生在邮件列表上，所有共同体成员只需要关注论坛这一个渠道，就应该能够接收所有必要的信息。同时，在论坛上提出的问题，应该具有最高的响应优先级。</p>
<p>通过定义唯一信源，信息交互才能在当下这个沟通工具琳琅满目的环境下以一种尽可能低消耗的方式进行。否则，每个人都有他喜欢的沟通方式，甚至是非持久化或非公开的方式，例如不录屏的视频会议，或者微信聊天等等。如果在这些地方的讨论也可以作为信源，那么共同体当中发生的事情，将有可能只是一小部分人未经记录的部落共识。这种共同体当中具有排他性的小团体，对信息对等的流通是极其有害的。</p>
<p>回到解决“我应该怎么做到”这个问题上来，信源的分裂也将提高潜在的参与者理解到底应该在哪里解决他“最后一公里”问题的难度。也就是说，解决“最后一公里”问题的路径，本身成为了“最后一公里”问题的一部分。</p>
<p>选择论坛而不是邮件列表，体现了用户喜好的差异。其实对我来说，论坛和邮件列表的价值是一样的，无非是共同体成员更喜欢哪一个用户界面罢了。类似的，聊天室之于论坛，是用户沟通习惯上的差异。IRC 和 Zulip 在我看来也是一样的，无非是共同体成员更喜欢哪一个罢了。只要指定一个，就可以减少工具数量爆炸带来的信息熵。</p>
<p>不过，聊天室作为即时沟通工具，较之论坛或者相对更为正式的邮件，在即时响应问题上有独特的优势。一两句话能解决的问题，即时通信工具更加轻量级。模糊概念的讨论，即时通信工具能够更好地完成实时的头脑风暴。前者的典型例如 <a href="https://gitter.im/akka/akka">Akka 的 Gitter 聊天室</a>，后者的典型例如 <a href="https://rust-lang.zulipchat.com/">Rust 的 Zulip 聊天室</a>。</p>
<p>但是，聊天室核心的问题就在于它的信息密度太低，一旦超过一百人，昨天的消息基本上就已经完全归入历史，要想重提就得从头再来了。虽然现代聊天室大多支持主题化讨论的功能，但是较之论坛的设计理念，还是比较薄弱。因此我在设计沟通工具方案的时候，总是以论坛作为唯一信源。同时在选择聊天室方案的时候，总是选择公开的聊天室，选择支持主题化讨论的聊天室，选择支持引用内容链接的聊天室。支持引用内容链接，就可以在论坛当中直接链接到聊天室的特定讨论串当中，从而打通两边内容的交叉引用。这样避免了大量内容存在于聊天室当中，削弱论坛定位的情况，既能维护论坛唯一信源的定位，又能利用即时通信的优势。</p>
]]></content>
      <categories>
        <category>tison</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
        <tag>开源治理</tag>
      </tags>
  </entry>
  <entry>
    <title>开发者社区从何而来</title>
    <url>/flossway/2022/02/28/where-comes-the-community/</url>
    <content><![CDATA[<p>开源软件项目与开发者社区谁先谁后？开源项目是否是社区的基石？项目团队如何在社区面前摆正自己的位置？</p>
<span id="more"></span>

<p><strong>开源</strong>（open source）很火，开源软件公司融资也很火。所以很多公司，很多人，都想赶个潮流搞“开源”。而“开源”离不开“社区”。那么，什么又是开源社区呢？</p>
<p>开源社区，是由围绕着开源软件项目而聚集的技术人员所组成的。这些技术人员依据开源的准则行事，共同将这个开源项目发展壮大。为了促进社区的健康发展，我们需要制定一系列的开源流程，或者遵循开源的最佳实践。</p>
<p>我以前就是这么认为的，但我渐渐发现我可能是搞反了。开源项目与开源社区，究竟谁先谁后？这可能是开发者社区运营中最重要的“元问题”。</p>
<p>按之前大多数人的思路，首先有一个开源项目，然后项目团队围绕这个项目本身开始做文章。技术的先进性，开发过程的开放性，活动的丰富性等等。经过一番努力，项目团队构建起了一个以此项目为基石的社区。项目团队为项目发展作出的努力固然值得尊敬，但社区是他们建立起来的吗？</p>
<p><strong>我现在倾向于认为，开发者社区是伴随 IT 行业出现的自然产物。社区的源头是出现了软件开发者这样的高度专业化人群，而不是具体的某一个软件项目。</strong></p>
<p>软件开发者不同于医生，律师，机械工程师这些专业人士，因为软件本身是虚拟的，不受限于时间和地点。因此软件开发者能够更容易的展开协作。注意，我说的是工作上的协作，而不是学术上的交流。比如，上海和北京的两个软件开发人员可以隔着上千公里一起写同一个软件项目。但相隔千里的医生或者律师，在目前的技术条件下就比较难以共同合作了。因此程序员之间可以发展出“开源”这样的行事准则，以支撑软件开发中的开放式合作。所以说开源社区从属于开发者社区，它来自于开发者本身，而不是某个具体的项目。</p>
<p>那么如何理解开源软件与社区之间的关系？我不认为应该把某个开源软件当作是社区的基石。<strong>某个开源软件更像是一个有趣的“游乐场”，吸引了社区中的程序员。如果程序员从中获得了乐趣，那么会有更多人愿意来这个“游乐场”。</strong></p>
<p>从这个角度来看，开源软件的项目团队需要好好思考与社区之间的关系。创造开发者社区，掌控开发者社区，这些都是常见的迷惑性思维。开发者社区常在，而项目不常在。项目团队应该把心思放在做好自己的项目，保持“游乐场”的趣味性上。</p>
<p>这便是对开发者社区最大的尊重。</p>
]]></content>
      <categories>
        <category>顾钧</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>社区</tag>
      </tags>
  </entry>
</search>
